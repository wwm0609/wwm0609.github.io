[{"categories":null,"content":"本文介绍Android上定位native代码野指针/数组越界/栈踩踏的强大武器: Address Sanitizer(asan)和Hardware assisted Address Sanitizer (hwasan)的基本实现原理 Address Sanitizer ","date":"2020-04-17","objectID":"/hwasan/:0:0","tags":["asan","hwasan","野指针","越界","栈踩踏","use-after-free"],"title":"Android Hardware Assisted Address Sanitizer原理简介","uri":"/hwasan/"},{"categories":null,"content":"基本原理 程序申请的每8bytes内存映射到1byte的shadown内存上 因为malloc返回的地址都是基于8字节对齐的，所以每8个字节实际可能有以下几个状态 case 1：8个字节全部可以访问，例如char* p = new char[8]; 将0写入到这8个字节对应的1个字节的shadow内存； case 2：前1\u003c=n\u003c8个字节可以访问, 例如char* p = new char[n], 将数值n写入到相应的1字节的shadow内存，尽管这个对象实际只占用5bytes，malloc的实现里[p+5, p+7]这尾部的3个字节的内存也不会再用于分配其他对象，所以通过指针p来越界访问最后3个字节的内存也是被允许的 asan还会在程序申请的内存的前后，各增加一个redzone区域（n * 8bytes），用来解决overflow/underflow类问题 free对象时，asan不会立即把这个对象的内存释放掉，而是写入1个负数到该对象的shadown内存中，即将该对象成不可读写的状态， 并将它记录放到一个隔离区(book keeping)中, 这样当有野指针或use-after-free的情况时，就能跟进shadow内存的状态，发现程序的异常；一段时间后如果程序没有异常，就会再释放隔离区中的对象 编译器在对每个变量的load/store操作指令前都插入检查代码，确认是否有overflow、underflow、use-after-free等问题 ","date":"2020-04-17","objectID":"/hwasan/:1:0","tags":["asan","hwasan","野指针","越界","栈踩踏","use-after-free"],"title":"Android Hardware Assisted Address Sanitizer原理简介","uri":"/hwasan/"},{"categories":null,"content":"检测堆上变量的非法操作的基本实现方式 asan在运行时会替换系统默认的malloc实现，当执行以下代码时， void foo() { char* ptr = new char[10]; ptr[1] = 'a'; ptr[10] = '\\n' } 我们知道new关键字实际最终调用还是malloc函数，而asan提供的malloc实现基本就如下代码片段所示： // asan提供的malloc函数 void* asan_malloc(size_t requested_size) { size_t actual_size = RED_ZONE_SIZE /*前redzone*/ + align8(requested_size) + RED_ZONE_SIZE/*后redzone*/; // 调用libc的malloc去真正的分配内存 char* p = (char*)libc_malloc(acutal_size); // 标记前后redzone区不可读写 poison(p, requested_size); return p + RED_ZONE_SIZE; // 返回偏移后的地址 } void foo() { // 运行时实际执行的代码 char* ptr = asan_malloc(10); // 编译器插入的代码 if (isPoisoned(ptr+1)) { abort(); } ptr[1] = 'a'; // 编译器插入的代码 if (isPoisoned(ptr+10)) { abort(); // crash： 访问到了redzone区域 } ptr[10] = '\\n' } asan_malloc会额外多申请2个redzone大小的内存, 实际的内存布局如下所示： ---------------------------------------------------------------- | redzone（前） | 用户申请的内存 | redzone(后) | ---------------------------------------------------------------- 用户申请的内存对应的shadow内存会被标记成可读写的，而redzone区域内存对应的shadow内存则会被标记成不可读写的, 这样就可以检测对堆上变量的越界访问类问题了。 ","date":"2020-04-17","objectID":"/hwasan/:1:1","tags":["asan","hwasan","野指针","越界","栈踩踏","use-after-free"],"title":"Android Hardware Assisted Address Sanitizer原理简介","uri":"/hwasan/"},{"categories":null,"content":"检测栈上对象的非法操作的基本实现方式 对于以下代码片段 void foo() { char a[8]; a[1] = '\\0'; a[8] = '\\0'; // 越界 return; } 编译器则直接在a数组的前后都插入1个redzone，最终的代码会变成下面的方式： void foo() { char redzone1[32]; // 编译器插入的代码, 32字节对齐 char a[8]; char redzone2[24]; // 编译器插入的代码, 与用于申请的数组a一起做32字节对齐 char redzone3[32]; // 编译器插入的代码, 32字节对齐 // 编译器插入的代码 int *shadow_base = MemToShadow(redzone1); shadow_base[0] = 0xffffffff; // 标记redzone1的32个字节都不可读写 shadow_base[1] = 0xffffff00; // 标记数组a的8个字节为可读写的，而redzone2的24个字节均不可读写 shadow_base[2] = 0xffffffff; // 标记redzone3的32个字节都不可读写 // 编译器插入的代码 if (isPoisoned(a+1)) { abort(); } a[1] = '0'; // 编译器插入的代码 if (isPoisoned(a+8)) { abort(); // crash: 因为a[8]访问到了redzone区 } a[8] = '\\0'; // 整个栈帧都要被回收了，所以要将redzone和数组a对应的内存都标记成可读可写的 shadow_base[0] = shadow_base[1] = shadow_base[2] = 0; return; } ","date":"2020-04-17","objectID":"/hwasan/:1:2","tags":["asan","hwasan","野指针","越界","栈踩踏","use-after-free"],"title":"Android Hardware Assisted Address Sanitizer原理简介","uri":"/hwasan/"},{"categories":null,"content":"程序申请的对象内存和它的shadow内存映射关系 因为asan对每8bytes程序内存会保留1byte的shadow内存，所以在进程初始化时，asan得预留(mmap)1/8的虚拟内存， 而对于64bit的Linux，实际最大可用虚拟地址是pow(2, 47), 另外要保证预留的地址不会被程序启动时就占用 掉，所以实际预留的地址要再加上一个适当的偏移, 这样就不会与app的申请内存区域重叠，于是有： ShadowByteAddr = (AppMemAddr \u003e\u003e 3) + Offset Hardware assisted address sanitizer 原理简介 依赖AArch64的address tagging，也叫top byte ignore特性，允许程序将自定义数据存到虚拟地址的最高8位（bit），cpu在操作这个虚拟地址的时候，会自动忽略高8位。 ","date":"2020-04-17","objectID":"/hwasan/:1:3","tags":["asan","hwasan","野指针","越界","栈踩踏","use-after-free"],"title":"Android Hardware Assisted Address Sanitizer原理简介","uri":"/hwasan/"},{"categories":null,"content":"基本原理 内存对齐：不论是在堆上，栈上分配的对象，还是全局对象，他们的内存起始地址都会做16bytes对齐（malloc或者编译器来保证） 标记内存：在分配这些对象时，hwasan挑选一个随机数值tag（\u003c=255），对这个对象做标记，并将它保存到这个对象的对应shadow内存中 标记指针：hwasan提供的malloc函数返回的对象虚拟地址的最高8bits也被设置成同样的tag值，栈上对象的标记工作由编译器完成 映射关系：每16 bytes程序内存映射到1 byte的shadow内存，用于保存tag值 回收对象：重新分配一个随机值，保存对象地址关联的shadow内存中，如果有人使用一个指向一个已经被释放了的对象指针去访问数据，由于tag已经发生了变化，就会被及时检测到 检验tag：跟asan类似，在对每个指针的store/load指令前，编译器都插入相应的检查指令，用于确认正在被读或写的指针的高8位上的tag值与指针所指向对象对应的shaow内存里的tag值是一致的，如果出现不一致就会终止当前进程。 另外，当分配的对象的内存实际小于16字节时，例如我们通过 char* p = new char[10] 分配一个长度是10byte的char数组，因为要保证每16个字节对应1个字节的shadow byte，所以[p+10, p+15]这6个字节的内存也不会再用于分配其他对象。而这部分预留的闲置内存的最后一个字节就可以用来存放数组的实际大小，这样的话，当检测到指针上的tag与shadow内存里的tag是一致时，还要再校验指针所指向对象的实际大小来检测是否有数组越界问题。 char* p = new char[10]; char* q = p + 11; *q = 1; // 数组访问越界 ","date":"2020-04-17","objectID":"/hwasan/:2:0","tags":["asan","hwasan","野指针","越界","栈踩踏","use-after-free"],"title":"Android Hardware Assisted Address Sanitizer原理简介","uri":"/hwasan/"},{"categories":null,"content":"原理图解 ","date":"2020-04-17","objectID":"/hwasan/:3:0","tags":["asan","hwasan","野指针","越界","栈踩踏","use-after-free"],"title":"Android Hardware Assisted Address Sanitizer原理简介","uri":"/hwasan/"},{"categories":null,"content":"hwasan的漏检率 对一个指针上的保存的tag值，它实际指向的对象所对应的shadow内存里的tag值可能有256（2^8）种可能。那么2个不同的对象就会有1/256，即大约 0.4% 的概率拥有相同tag的情况，这样的野指针/越界方位就不能及时的被检测到，但我们还是可以通过长时间的测试和多次测试来提高检测率。 ","date":"2020-04-17","objectID":"/hwasan/:4:0","tags":["asan","hwasan","野指针","越界","栈踩踏","use-after-free"],"title":"Android Hardware Assisted Address Sanitizer原理简介","uri":"/hwasan/"},{"categories":null,"content":"hwasan相比asan的优势 相比asan，hwsan的shadow memory占用更少（10% ~ 35%） hwsan也要对分配的栈/堆上的变量做16字节对齐*，还有每16个字节会占用1个字节的shadow内存**用于保存tag值，但它不再要像asan的实现里那样，在分配的对象前后添加redzone，来检查越界访问，所以内存占用会降低不少。 定位对于野指针类问题的概率更高 asan只能检测到一个野指针恰好访问的是某个对象之前或之后的redzone内存的情况，理论上redzone越大，能检测到野指针的概率也就越高，不过随之也会带来更大的内存开销(overload)； hwsan上，因为两个不同对象的tag值一般是不同的，所以只要是有野指针就能够被及时检测到。 ","date":"2020-04-17","objectID":"/hwasan/:5:0","tags":["asan","hwasan","野指针","越界","栈踩踏","use-after-free"],"title":"Android Hardware Assisted Address Sanitizer原理简介","uri":"/hwasan/"},{"categories":null,"content":"参考 AddressSanitizer: A Fast Address Sanity Checker Detecting Memory Corruption Bugs With HWASan google/sanitizers Hardware-assisted AddressSanitizer Design Documentation ","date":"2020-04-17","objectID":"/hwasan/:6:0","tags":["asan","hwasan","野指针","越界","栈踩踏","use-after-free"],"title":"Android Hardware Assisted Address Sanitizer原理简介","uri":"/hwasan/"},{"categories":null,"content":"背景 在分配file descriptors时, POSIX标准规定了内核必须从所有可被使用的fd数值中最小的一个, 参考alloc_fd，如果代码里没有正确的处理好fd的open/close等操作，就可能会带来以下2个副作用： use-after-close double-close 示例: double-close问题 void thread_one() { int fd = open(\"/dev/null\", O_RDONLY); doWork(fd); close(fd); } void doWork(int fd) { doSomething(); close(fd); } void thread_two() { int fd = open(\"log\", O_WRONLY | O_APPEND); if (write(fd, \"foo\", 3) != 3) { err(1, \"write failed!\"); } } 上面的代码可能产生下面的行为，导致线程2写入失败： // 线程1 线程2 open(\"/dev/null\", O_RDONLY) = 123 close(123) = 0 // during doWork() open(\"log\", O_WRONLY | APPEND) = 123 close(123) = 0 write(123, \"foo\", 3) = -1 (EBADF) err(1, \"write failed!\") ","date":"2019-11-07","objectID":"/fdsan/:1:0","tags":["file descriptor","double-close","use-after-close"],"title":"FdSanitizer 简介","uri":"/fdsan/"},{"categories":null,"content":"Fd Sanitizer Aosp在Android 10.0里，引入了一个fdsan机制，在发生前一节描述的异常行为时，可以选择让进程终止执行，并打印出发生错误线程的调用栈，这样开发者可以根据调用栈，快速了解出问题的模块，后面再去修正它。 先思考一个问题，设计一种检测前面的fd误操作问题的机制，需要考虑哪些东西？ api向前兼容 不能修改libc已有的api 鉴别一个fd的合法性 我的fd真的是我的吗，我能使用它吗？ 友好的错误提示 别人用了我的fd，或我用了别人的fd时，如何确认这个fd的拥有者？我们还需要backtrace！ ","date":"2019-11-07","objectID":"/fdsan/:2:0","tags":["file descriptor","double-close","use-after-close"],"title":"FdSanitizer 简介","uri":"/fdsan/"},{"categories":null,"content":"double-close 或 use-after-close问题的本质 double-close和use-after-close本质上都是使用了一个已经被关闭的fd，只不过这里面有几种不同情况： 线程1连续对同一个fd关闭2次，那么可能会因为EBADF而导致进程abort 线程1对同一个fd关闭了\u003e=2次，而如果在第一次和第二次关闭期间，线程2此时刚刚打开一个文件或socket，那么 就可能出现：线程1的第二次关闭的fd，正好等于线程2新打开的fd，而线程1的第二次关闭操作（意外）错误的把 线程2创建的fd给关闭了，此后线程2如果对这个fd进行读写等操作就会失败 线程1关闭了一个fd后，线程2立即新打开了一个fd，如果线程2新打开的fd对应的是一个结构化的文件，例如数据库文件、xml文件等， 线程1意外的在关闭fd后，又尝试向这个fd写入数据，就有可能线程2操作的文件的结构被破坏！ 我们可以看到问题的核心就是对fd的控制权(ownership)问题： 当我们对1个fd拥有控制权时，我们期望其别人不能对我们的fd进行操作，反过来也是，当一个fd的控制权在别人那时，也期望我们不会去操作他们的fd！ ","date":"2019-11-07","objectID":"/fdsan/:2:1","tags":["file descriptor","double-close","use-after-close"],"title":"FdSanitizer 简介","uri":"/fdsan/"},{"categories":null,"content":"unique_fd！ 类似智能指针(unique_ptr)，用户代码里使用unique_fd，在各个函数间进行参数传递时，也是使用unique_fd来进行，而不是原先的传递raw fd，这样这个fd从open到close，都会有个唯一的unique_fd来标明它的控制权。 而且因为unique_fd重载了operator int()，所以它可以完美兼容已有的libc接口。 class unique_fd_impl final { public: explicit unique_fd_impl(int fd) { reset(fd); } ~unique_fd_impl() { reset(); } void reset(int new_value = -1) { reset(new_value, nullptr); } void reset(int new_value, void* previous_tag) { int previous_errno = errno; if (fd_ != -1) { close(fd_, this); } fd_ = new_value; if (new_value != -1) { tag(new_value, previous_tag, this); // 对这个fd打tag，即声明控制权 } errno = previous_errno; } static void Close(int fd, void* addr) { uint64_t tag = android_fdsan_create_owner_tag(ANDROID_FDSAN_OWNER_TYPE_UNIQUE_FD, reinterpret_cast\u003cuint64_t\u003e(addr)); android_fdsan_close_with_tag(fd, tag); } private: int fd_ = -1; } using unique_fd = unique_fd_impl\u003cDefaultCloser\u003e; 使用方式： #include \u003candroid-base/unique_fd.h\u003e void test(const char* path) { android::base::unique_fd fd(open(path, O_WRONLY)); write(fd, \"foo\", 3); // close(fd); 无需手动关闭fd } 下面先通过分析unique_fd的代码来一窥fdsan的检测原理： // bionic/libc/bionic/fdsan.cpp static void tag(int fd, void* old_addr, void* new_addr) { uint64_t old_tag = android_fdsan_create_owner_tag(ANDROID_FDSAN_OWNER_TYPE_UNIQUE_FD, reinterpret_cast\u003cuint64_t\u003e(old_addr)); uint64_t new_tag = android_fdsan_create_owner_tag(ANDROID_FDSAN_OWNER_TYPE_UNIQUE_FD, reinterpret_cast\u003cuint64_t\u003e(new_addr)); android_fdsan_exchange_owner_tag(fd, old_tag, new_tag); } uint64_t android_fdsan_create_owner_tag(android_fdsan_owner_type type, uint64_t tag) { if (tag == 0) { return 0; } // 高8位用于标记fd类型 uint64_t result = static_cast\u003cuint64_t\u003e(type) \u003c\u003c 56; // 即00000000,11111111,11111111,11111111,11111111,11111111,11111111,11111111 uint64_t mask = (static_cast\u003cuint64_t\u003e(1) \u003c\u003c 56) - 1; // 低56位用于标记fd的owner，若owner是unique_fd的话，参考前面的代码，可以知道即取unique_fd地址的低56位 // note: 没有存地址的全部64位，是因为用户空间的变量地址，一般高8～16位一般都是0， // 高8位于是就可以用来下来存储type, 感兴趣的朋友可以看下linux的进程地址空间分布。 result |= tag \u0026 mask; return result; } struct FdEntry { _Atomic(uint64_t) close_tag = 0; }; void android_fdsan_exchange_owner_tag(int fd, uint64_t expected_tag, uint64_t new_tag) { FdEntry* fde = GetFdEntry(fd); if (!fde) { return; } uint64_t tag = expected_tag; if (!atomic_compare_exchange_strong(\u0026fde-\u003eclose_tag, \u0026tag, new_tag)) { if (expected_tag \u0026\u0026 tag) { fdsan_error( \"failed to exchange ownership of file descriptor: fd %d is \" \"owned by %s 0x%\" PRIx64 \", was expected to be owned by %s 0x%\" PRIx64, fd, android_fdsan_get_tag_type(tag), android_fdsan_get_tag_value(tag), android_fdsan_get_tag_type(expected_tag), android_fdsan_get_tag_value(expected_tag)); } else if (expected_tag \u0026\u0026 !tag) { fdsan_error( \"failed to exchange ownership of file descriptor: fd %d is \" \"unowned, was expected to be owned by %s 0x%\" PRIx64, fd, android_fdsan_get_tag_type(expected_tag), android_fdsan_get_tag_value(expected_tag)); } else if (!expected_tag \u0026\u0026 tag) { fdsan_error( \"failed to exchange ownership of file descriptor: fd %d is \" \"owned by %s 0x%\" PRIx64 \", was expected to be unowned\", fd, android_fdsan_get_tag_type(tag), android_fdsan_get_tag_value(tag)); } } } 流程很简单，以上创建unique_fd时的tag操作系列调用，就是对fd控制权记录的检查和更新： unique_fd创建的时候，对传入的参数fd进行检查，如果ownership不匹配，便会输出warning日志或abort（可配置）； 同样的，unique_fd销毁时，也会检查内部保存的fd的控制权是否依然还属于当前的unique_fd，如果是，则可以将其关闭； 如果控制权丢失了，那么通过fdsan_error打印相应的错误信息，并根据配置再采取是否需要终止当前进程的操作。 // bionic/libc/bionic/fdsan.cpp int android_fdsan_close_with_tag(int fd, uint64_t expected_tag) { FdEntry* fde = GetFdEntry(fd); if (!fde) { return ___close(fd); } uint64_t tag = expected_tag; if (!atomic_compare_exchange_strong(\u0026fde-\u003eclose_tag, \u0026tag, 0)) { const char* expected_type = android_fdsan_get_tag_type(expected_tag); uint64_t expected_owner = android_fdsan_get_tag_value(expected_tag); const char* actual_type = android_fdsan_get_tag_type(tag); uint64_t actual_owner = android_fdsan_get_tag_value(tag); if (expected_tag \u0026\u0026 tag) { fdsan_error( \"attempted to close file descriptor %d, \" \"expected to be owned by %s 0x%\" PRIx64 \", actu","date":"2019-11-07","objectID":"/fdsan/:2:2","tags":["file descriptor","double-close","use-after-close"],"title":"FdSanitizer 简介","uri":"/fdsan/"},{"categories":null,"content":"自定义fd类型 自定义fd类型主要是为了便于详细区分不同模块间创建的fd，例如zip文件的fd，sqlite3的fd，java代码里的FileInputStream和FileOutputStream等，下面看一下这几类fd的控制权是如何创建和管理的。 zip类型的文件 // system/core/libziparchive/zip_archive.cc ZipArchive::ZipArchive(const int fd, bool assume_ownership) : mapped_zip(fd), close_file(assume_ownership), directory_offset(0), central_directory(), directory_map(), num_entries(0), hash_table_size(0), hash_table(nullptr) { if (assume_ownership) { // 如果调用方明确了此fd由libzip自行管理 android_fdsan_exchange_owner_tag(fd, 0, GetOwnerTag(this)); } } uint64_t GetOwnerTag(const ZipArchive* archive) { return android_fdsan_create_owner_tag(ANDROID_FDSAN_OWNER_TYPE_ZIPARCHIVE, reinterpret_cast\u003cuint64_t\u003e(archive)); } ZipArchive::~ZipArchive() { if (close_file \u0026\u0026 mapped_zip.GetFileDescriptor() \u003e= 0) { android_fdsan_close_with_tag(mapped_zip.GetFileDescriptor(), GetOwnerTag(this)); } free(hash_table); } ","date":"2019-11-07","objectID":"/fdsan/:2:3","tags":["file descriptor","double-close","use-after-close"],"title":"FdSanitizer 简介","uri":"/fdsan/"},{"categories":null,"content":"数据库文件 // external/sqlite/dist/sqlite3.c static int robust_open(const char *z, int f, mode_t m){ int fd; mode_t m2 = m ? m : SQLITE_DEFAULT_FILE_PERMISSIONS; while(1){ #if defined(O_CLOEXEC) fd = osOpen(z,f|O_CLOEXEC,m2); #else fd = osOpen(z,f,m2); #endif... #if defined(__BIONIC__) \u0026\u0026 __ANDROID_API__ \u003e= __ANDROID_API_Q__ uint64_t tag = android_fdsan_create_owner_tag( ANDROID_FDSAN_OWNER_TYPE_SQLITE, fd); android_fdsan_exchange_owner_tag(fd, 0, tag); #endif } return fd; } static void robust_close(unixFile *pFile, int h, int lineno){ #if defined(__BIONIC__) \u0026\u0026 __ANDROID_API__ \u003e= __ANDROID_API_Q__ uint64_t tag = android_fdsan_create_owner_tag( ANDROID_FDSAN_OWNER_TYPE_SQLITE, h); if( android_fdsan_close_with_tag(h, tag) ){ #else if( osClose(h) ){ #endif unixLogErrorAtLine(SQLITE_IOERR_CLOSE, \"close\", pFile ? pFile-\u003ezPath : 0, lineno); } } ","date":"2019-11-07","objectID":"/fdsan/:2:4","tags":["file descriptor","double-close","use-after-close"],"title":"FdSanitizer 简介","uri":"/fdsan/"},{"categories":null,"content":"fopen/fclose 请参考bionic/libc/stdio/stdio.cpp#__FILE_close，不再详细描述 ","date":"2019-11-07","objectID":"/fdsan/:2:5","tags":["file descriptor","double-close","use-after-close"],"title":"FdSanitizer 简介","uri":"/fdsan/"},{"categories":null,"content":"java代码里打开的fd ParcelFileDescriptor public class ParcelFileDescriptor implements Parcelable, Closeable { ... public ParcelFileDescriptor(FileDescriptor fd, FileDescriptor commChannel) { mFd = fd; // 1. 通过jni调用前面的fdsan api设置这个fd的owner, 且将owner信息存储到FileDescriptor.ownerId变量里 IoUtils.setFdOwner(mFd, this); ... } public void close() throws IOException { closeWithStatus(Status.OK, null); } private void closeWithStatus(int status, String msg) { if (mClosed) return; mClosed = true; if (mGuard != null) { mGuard.close(); } // Status MUST be sent before closing actual descriptor writeCommStatusAndClose(status, msg); IoUtils.closeQuietly(mFd); // 2. 调用IoUtils工具类关闭这个fd releaseResources(); } } public final class IoUtils { public static void close(FileDescriptor fd) throws IOException { IoBridge.closeAndSignalBlockedThreads(fd); // 3. 代理到IoBridge进行关闭 } public static void setFdOwner(@NonNull FileDescriptor fd, @NonNull Object owner) { long previousOwnerId = fd.getOwnerId$(); if (previousOwnerId != FileDescriptor.NO_OWNER) { throw new IllegalStateException(\"Attempted to take ownership of already-owned \" + \"FileDescriptor\"); } long ownerId = generateFdOwnerId(owner); fd.setOwnerId$(ownerId); // Set the file descriptor's owner ID, aborting if the previous value isn't as expected. Libcore.os.android_fdsan_exchange_owner_tag(fd, previousOwnerId, ownerId); } } public final class IoBridge { public static void closeAndSignalBlockedThreads(FileDescriptor fd) throws IOException { // fd is invalid after we call release. FileDescriptor oldFd = fd.release$(); Libcore.os.close(oldFd); // Libcore.os.close实际由libcore.io.Linux.close这个native方法实现 } } libcore.io.Linux.close方法的实现： // libcore/luni/src/main/native/libcore_io_Linux.cpp static void Linux_close(JNIEnv* env, jobject, jobject javaFd) { // Get the FileDescriptor's 'fd' field and clear it. // We need to do this before we can throw an IOException (http://b/3222087). if (javaFd == nullptr) { jniThrowNullPointerException(env, \"null fd\"); return; } int fd = jniGetFDFromFileDescriptor(env, javaFd); jniSetFileDescriptorOfFD(env, javaFd, -1); jlong ownerId = jniGetOwnerIdFromFileDescriptor(env, javaFd); // 通过jni获取到FileDescriptor.mOwnerId成员变量 // Close with bionic's fd ownership tracking (which returns 0 in the case of EINTR). throwIfMinusOne(env, \"close\", android_fdsan_close_with_tag(fd, ownerId)); } FileInputStream \u0026 FileOutputStream 跟ParcelableFileDescriptor的实现类似，不再详述 PlainSocketImpl \u0026 AbstractPlainDatagramSocketImpl 略 RandomAccessFile 略 ","date":"2019-11-07","objectID":"/fdsan/:2:6","tags":["file descriptor","double-close","use-after-close"],"title":"FdSanitizer 简介","uri":"/fdsan/"},{"categories":null,"content":"如何查看进程的fdan记录 $ adb shell cepheus:/ # debuggerd `pidof system_server` ... fd 106: anon_inode:[eventfd] (owned by unique_fd 0x70c672a8f4) fd 107: anon_inode:[eventpoll] (owned by unique_fd 0x70c672a94c) fd 108: anon_inode:[eventpoll] (owned by unique_fd 0x70d027f6ec) fd 109: anon_inode:[eventfd] (owned by unique_fd 0x70c672c6b4) fd 110: anon_inode:[eventpoll] (owned by unique_fd 0x70c672c70c) fd 111: socket:[582031] (unowned) fd 112: anon_inode:[eventfd] (owned by unique_fd 0x70d027fa14) fd 113: anon_inode:[eventpoll] (owned by unique_fd 0x70d027fa6c) fd 114: /dev/cpuset/foreground/tasks (owned by unique_fd 0x70dd5a4ad0) fd 115: /system/priv-app/SettingsProvider/SettingsProvider.apk (owned by ZipArchive 0x70dd59f100) fd 116: anon_inode:[eventfd] (owned by unique_fd 0x70c672ca34) fd 117: anon_inode:[eventpoll] (owned by unique_fd 0x70c672ca8c) fd 118: /dev/ashmem (unowned) ... ","date":"2019-11-07","objectID":"/fdsan/:3:0","tags":["file descriptor","double-close","use-after-close"],"title":"FdSanitizer 简介","uri":"/fdsan/"},{"categories":null,"content":"如何启用fdsan fdsan在Q上是默认启用的，只不过在遇到fd误操作问题时，预设的行为仅是打印一些警示日志。 比较让人高兴的是，fdsan也定义了不同的安全级别： disabled：禁用 warn-once：只在第一次打印一条警告日志，并在/data/tombstone/目录下生成异常进程的调用栈 warn-always：跟warn-once一样，只不过每次出现fd误操作都会打印警告日志和生成tombstone文件 fatal：abort进程，并生成tombstone文件 fd也开放了对应的api可以让我们去调整一个进程在遇到此类异常时的行为：android_fdsan_set_error_level \u0026 android_fdsan_get_error_level，这样可以配置进程在遇到此类错误时，选择立即abort进程，并配置生成core文件，然后就可以愉快的去debug了！ ","date":"2019-11-07","objectID":"/fdsan/:4:0","tags":["file descriptor","double-close","use-after-close"],"title":"FdSanitizer 简介","uri":"/fdsan/"},{"categories":null,"content":"兼容性问题 由于fdsan是在Q上libc里才引入的机制，对于Android旧版本是没有做支持的，而且我也check了一下20.0.5594570版的ndk，也没有把unique_fd工具类给开发出来，这对于系统开发人员到没有太大影响，但对于app开发，就需要自己实现一个unique_fd类，另外老版本Android系统上并没有这些fdsan api，我自己也写了一个unique_fd_compat类，用来解决编译问题，仅供参考。 另外一个小tip：libc里预定义的fd owner类型比较少： // bionic/libc/include/android/fdsan.h enum android_fdsan_owner_type { ... /* android::base::unique_fd */ ANDROID_FDSAN_OWNER_TYPE_UNIQUE_FD = 3, /* sqlite-owned file descriptors */ ANDROID_FDSAN_OWNER_TYPE_SQLITE = 4, /* java.io.FileInputStream */ ANDROID_FDSAN_OWNER_TYPE_FILEINPUTSTREAM = 5, /* java.io.FileOutputStream */ ANDROID_FDSAN_OWNER_TYPE_FILEOUTPUTSTREAM = 6, /* java.io.RandomAccessFile */ ANDROID_FDSAN_OWNER_TYPE_RANDOMACCESSFILE = 7, /* android.os.ParcelFileDescriptor */ ANDROID_FDSAN_OWNER_TYPE_PARCELFILEDESCRIPTOR = 8, /* java.net.SocketImpl */ ANDROID_FDSAN_OWNER_TYPE_SOCKETIMPL = 11, /* libziparchive's ZipArchive */ ANDROID_FDSAN_OWNER_TYPE_ZIPARCHIVE = 12, }; 但从前面的分析，我们发现，其实它是可以支持到255个不同类型的，这样的话在我们自己实现的unique_fd里就可以做到支持不同模块设置不同的子类型，例如audio，video模块可以各自预设不同的子类型，以便于出现问题时快速区分。 ","date":"2019-11-07","objectID":"/fdsan/:5:0","tags":["file descriptor","double-close","use-after-close"],"title":"FdSanitizer 简介","uri":"/fdsan/"},{"categories":null,"content":"Aosp官方介绍 https://android.googlesource.com/platform/bionic/+/master/docs/fdsan.md ","date":"2019-11-07","objectID":"/fdsan/:6:0","tags":["file descriptor","double-close","use-after-close"],"title":"FdSanitizer 简介","uri":"/fdsan/"},{"categories":null,"content":"背景： 从测试同学那边拿过来两台黑屏的机器，点击电源、屏幕都没有反应，不过还好adb可以链接，有root权限，一番deubgging后，确认表面原因是system_server进程的art虚拟机卡在了gc前flip线程状态的操作中，而最终的root cause也比较有意思，所以本文就简单记录下问题的排查过程。 1. 按照习惯，快速检查下是否发生了watchdog $ adb shell ``ls` `-l ``/data/anr/ -rw------- 1 system system 53592 2019-05-03 14:21 anr_2019-05-03-14-21-53-368 -rw------- 1 system system 845398 2019-05-03 14:30 anr_2019-05-03-14-30-03-498 -rw------- 1 system system 1078028 2019-05-03 14:58 anr_2019-05-03-14-58-40-505 -rw------- 1 system system 1060669 2019-05-03 14:59 anr_2019-05-03-14-59-00-410 -rw------- 1 system system 527393 2019-05-03 17:32 anr_2019-05-03-17-32-22-852 -rw------- 1 system system 619826 2019-05-03 17:33 anr_2019-05-03-17-32-58-212 // ... 并没有watchdog相关日志 2. 查看系统当前时间 `$ adb shell ``date``Sun May 5 13:52:25 CST 2019` 3. 查看system_server进程各个线程的状态 $ pid=`adb shell pidof system_server` \u0026\u0026 adb shell ``ps` `-T $pid USER PID TID PPID VSZ RSS WCHAN ADDR S CMD system 1471 1471 635 11629888 168336 futex_wait_queue_me 0 S system_server system 1471 1477 635 11629888 168336 do_sigtimedwait 0 S Signal Catcher system 1471 1478 635 11629888 168336 futex_wait_queue_me 0 S ADB-JDWP Connec system 1471 1479 635 11629888 168336 futex_wait_queue_me 0 S Binder:filter-p system 1471 1480 635 11629888 168336 poll_schedule_timeout 0 S Binder:``read``-per system 1471 1481 635 11629888 168336 futex_wait_queue_me 0 S ReferenceQueueD system 1471 1482 635 11629888 168336 futex_wait_queue_me 0 S FinalizerDaemon system 1471 1483 635 11629888 168336 futex_wait_queue_me 0 S FinalizerWatchd system 1471 1484 635 11629888 168336 futex_wait_queue_me 0 S HeapTaskDaemon system 1471 1524 635 11629888 168336 futex_wait_queue_me 0 S Binder:1471_1 system 1471 1525 635 11629888 168336 futex_wait_queue_me 0 S Binder:1471_2 system 1471 1673 635 11629888 168336 futex_wait_queue_me 0 S android.``bg system 1471 1675 635 11629888 168336 futex_wait_queue_me 0 S ActivityManager system 1471 1676 635 11629888 168336 SyS_epoll_wait 0 S android.ui system 1471 1677 635 11629888 168336 SyS_epoll_wait 0 S ActivityManager system 1471 1678 635 11629888 168336 SyS_epoll_wait 0 S ActivityManager system 1471 1684 635 11629888 168336 futex_wait_queue_me 0 S batterystats-wo system 1471 1687 635 11629888 168336 wait_woken 0 S FileObserver system 1471 1688 635 11629888 168336 futex_wait_queue_me 0 S android.``fg system 1471 1689 635 11629888 168336 futex_wait_queue_me 0 S android.io system 1471 1690 635 11629888 168336 futex_wait_queue_me 0 S android.display system 1471 1691 635 11629888 168336 futex_wait_queue_me 0 S CpuTracker system 1471 1692 635 11629888 168336 futex_wait_queue_me 0 S PowerManagerSer system 1471 1693 635 11629888 168336 futex_wait_queue_me 0 S BatteryStats_wa system 1471 1694 635 11629888 168336 SyS_epoll_wait 0 S work-thread system 1471 1695 635 11629888 168336 SyS_epoll_wait 0 S PackageManager system 1471 1696 635 11629888 168336 SyS_epoll_wait 0 S PackageManager system 1471 1817 635 11629888 168336 SyS_epoll_wait 0 S PackageInstalle system 1471 1821 635 11629888 168336 SyS_epoll_wait 0 S android.anim system 1471 1822 635 11629888 168336 SyS_epoll_wait 0 S android.anim.lf ... 这一步主要是快速检查下有没有D（disk blocked）状态的线程 3. 查看system_server进程backtrace $ pid=`adb shell pidof system_server` \u0026\u0026 adb shell ``kill` `-3 $pid 得到： 点击展开完整backtrace! ----- pid 1471 at 2019-05-05 11:07:04 ----- Cmd line: system_server Build fingerprint: 'Xiaomi/ursa/ursa:9/PKQ1.180729.001/9.4.25:user/release-keys' ABI: 'arm64' Build type: optimized Zygote loaded classes=8981 post zygote classes=4480 Intern table: 91336 strong; 9128 weak JNI: CheckJNI is off; globals=35793 (plus 15391 weak) Libraries: /system/lib64/libandroid.so /system/lib64/libandroid_servers.so /system/lib64/libcompiler_rt.so /system/lib64/libjavacrypto.so /system/lib64/libjnigraphics.so /system/lib64/libmedia_jni.so /system/lib64/libmiui_security.so /system/lib64/libmiuiclassproxy.so /system/lib64/libmiuinative.so /system/lib64/libqti_performance.so /system/lib64/libshell_jni.so /system/lib64/li","date":"2019-05-17","objectID":"/art-jni-critical-deadlock/:0:1","tags":["jni","gdb","debuggerd"],"title":"art gc相关死锁黑屏问题总结","uri":"/art-jni-critical-deadlock/"},{"categories":null,"content":"记录一下这个问题的分析过程，主要是分享下Eclipse MAT的使用技巧 ：-) ","date":"2018-12-25","objectID":"/binder-proxy-leak/:0:0","tags":["binder","mat","hprof"],"title":"system_server BinderProxy相关泄露问题记录","uri":"/binder-proxy-leak/"},{"categories":null,"content":"问题现象 在长时间的稳定性测试后，经常遇到下面2类错误导致的重启，9.0上遇到的比较多的是这个java层报错： java.lang.AssertionError: Binder ProxyMap has too many entries: 20440 (total), 20272 (uncleared), 20176 (uncleared after GC). BinderProxy leak? 而8.0上报的都是下面这个global reference overflow的NE问题： pid: 1505, tid: 2994, name: Binder:1505_B \u003e\u003e\u003e system_server \u003c\u003c\u003c signal 6 (SIGABRT), code -6 (SI_TKILL), fault addr -------- Abort message: 'indirect_reference_table.cc:255] JNI ERROR (app bug): global reference table overflow (max=51200)' ","date":"2018-12-25","objectID":"/binder-proxy-leak/:1:0","tags":["binder","mat","hprof"],"title":"system_server BinderProxy相关泄露问题记录","uri":"/binder-proxy-leak/"},{"categories":null,"content":"问题1：Binder ProxyMap has too many entries 这个错误信息十分清晰，BinderProxy实例的数量太多，在执行一次gc后，system_server进程依然有20176个存活的BinderProxy对象。 仔细再看下异常调用栈： at android.os.BinderProxy$ProxyMap.set(Binder.java:951) at android.os.BinderProxy.getInstance(Binder.java:1078) at android.os.Parcel.nativeReadStrongBinder(Native Method) at android.os.Parcel.readStrongBinder(Parcel.java:2035) at android.app.IActivityManager$Stub.onTransact(IActivityManager.java:480) at com.android.server.am.ActivityManagerService.onTransact(ActivityManagerService.java:3383) at android.os.Binder.execTransact(Binder.java:733) final class BinderProxy implements IBinder { // called from native code private static BinderProxy getInstance(long nativeData, long iBinder) { BinderProxy result = sProxyMap.get(iBinder); if (result != null) { return result; } result = new BinderProxy(nativeData); sProxyMap.set(iBinder, result); return result; } private static final class ProxyMap { void set(long key, @NonNull BinderProxy value) { ... if (size \u003e= mWarnBucketSize) { final int totalSize = size(); mWarnBucketSize += WARN_INCREMENT; if (Build.IS_DEBUGGABLE \u0026\u0026 totalSize \u003e= CRASH_AT_SIZE) { // Use the number of uncleared entries to determine whether we should // really report a histogram and crash. We don't want to fundamentally // change behavior for a debuggable process, so we GC only if we are // about to crash. final int totalUnclearedSize = unclearedSize(); if (totalUnclearedSize \u003e= CRASH_AT_SIZE) { // CRASH_AT_SIZE = 20000 dumpProxyInterfaceCounts(); dumpPerUidProxyCounts(); Runtime.getRuntime().gc(); throw new AssertionError(\"Binder ProxyMap has too many entries: \" + totalSize + \" (total), \" + totalUnclearedSize + \" (uncleared), \" + unclearedSize() + \" (uncleared after GC). BinderProxy leak?\"); // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c ... } 结合代码后，了解到ProxyMap里会存放所有的java层BinderProxy对象，使用的时WeakReference，就是为了内存泄漏，我们知道，当WeakReference自身引用的对象 在没有被其他强引用占用时，WeakReference里的引用的对象就会被虚拟机在下次gc时自动回收掉。 现在既然存在BinderProxy泄漏，那肯定就是system_server进程里某个地方一直在持有着对BinderProxy对象，那么后面排查这个问题，我们就需要解决下面两个问题： 这20000多个BinderProxy对象都是哪些进程的Binder对象的代理？ 谁一直在强引用着这些BinderProxy对象？ ","date":"2018-12-25","objectID":"/binder-proxy-leak/:1:1","tags":["binder","mat","hprof"],"title":"system_server BinderProxy相关泄露问题记录","uri":"/binder-proxy-leak/"},{"categories":null,"content":"问题2： global reference table overflow global reference的详细用途，可以参考google文档，简单来说就是native代码里需要引用java层对象，为了防止被使用的java对象被gc回收掉，需要向虚拟机注册一个全局强引用，这样虚拟机gc时即使发现这个被引用的java对象已经没有其他java层对象持有后，也不会回收这个对象，直到global reference被取消掉，下次gc才可能会回收它； 还有个local reference，一般是在一个jni方法里，临时使用某个java对象时，先注册一个local reference，目的跟global reference是一样的。 这儿system_server进程crash的原因是global reference总的数量超过51200了，正常情况下不会有这么多引用，继续看一下这个详细的错误栈： 11-19 01:25:50.692 1000 12354 12354 F DEBUG : backtrace: 11-19 01:25:50.692 1000 12354 12354 F DEBUG : #00 pc 0000000000021f34 /system/lib64/libc.so (abort+116) 11-19 01:25:50.692 1000 12354 12354 F DEBUG : #01 pc 0000000000465478 /system/lib64/libart.so (art::Runtime::Abort(char const*)+1196) 11-19 01:25:50.692 1000 12354 12354 F DEBUG : #02 pc 0000000000008cd4 /system/lib64/libbase.so (android::base::LogMessage::~LogMessage()+724) 11-19 01:25:50.692 1000 12354 12354 F DEBUG : #03 pc 00000000002e7438 /system/lib64/libart.so (art::JavaVMExt::AddGlobalRef(art::Thread*, art::ObjPtr\u003cart::mirror::Object\u003e)+304) 11-19 01:25:50.692 1000 12354 12354 F DEBUG : #04 pc 000000000032ed7c /system/lib64/libart.so (art::JNI::NewGlobalRef(_JNIEnv*, _jobject*)+612) 11-19 01:25:50.692 1000 12354 12354 F DEBUG : #05 pc 0000000000131b20 /system/lib64/libandroid_runtime.so (JavaDeathRecipient::JavaDeathRecipient(_JNIEnv*, _jobject*, android::sp\u003cDeathRecipientList\u003e const\u0026)+136) 11-19 01:25:50.692 1000 12354 12354 F DEBUG : #06 pc 00000000001316a0 /system/lib64/libandroid_runtime.so (android_os_BinderProxy_linkToDeath(_JNIEnv*, _jobject*, _jobject*, int)+160) ... 结合BinderProxy.linkToDeath()的代码： public class Binder implements IBinder { ... final class BinderProxy implements IBinder { public native void linkToDeath(DeathRecipient recipient, int flags) // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c 1 throws RemoteException; ... } // frameworks/base/core/jni/android_util_Binder.cpp static void android_os_BinderProxy_linkToDeath(JNIEnv* env, jobject obj, jobject recipient, jint flags) // throws RemoteException { if (recipient == NULL) { jniThrowNullPointerException(env, NULL); return; } BinderProxyNativeData *nd = getBPNativeData(env, obj); IBinder* target = nd-\u003emObject.get(); if (!target-\u003elocalBinder()) { DeathRecipientList* list = nd-\u003emOrgue.get(); sp\u003cJavaDeathRecipient\u003e jdr = new JavaDeathRecipient(env, recipient, list); status_t err = target-\u003elinkToDeath(jdr, NULL, flags); // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c 2 ... } } class JavaDeathRecipient : public IBinder::DeathRecipient { public: JavaDeathRecipient(JNIEnv* env, jobject object, const sp\u003cDeathRecipientList\u003e\u0026 list) : mVM(jnienv_to_javavm(env)), mObject(env-\u003eNewGlobalRef(object)), // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c 3 mObjectWeak(NULL), mList(list) { // These objects manage their own lifetimes so are responsible for final bookkeeping. // The list holds a strong reference to this object. list-\u003eadd(this); gNumDeathRefsCreated.fetch_add(1, std::memory_order_relaxed); gcIfManyNewRefs(env); } } // art/runtime/jni_internal.cc namespace art { static jobject NewGlobalRef(JNIEnv* env, jobject obj) { ScopedObjectAccess soa(env); ObjPtr\u003cmirror::Object\u003e decoded_obj = soa.Decode\u003cmirror::Object\u003e(obj); return soa.Vm()-\u003eAddGlobalRef(soa.Self(), decoded_obj); } // art/runtime/java_vm_ext.cc static constexpr size_t kGlobalsMax = 51200; // Arbitrary sanity check. (Must fit in 16 bits.) jobject JavaVMExt::AddGlobalRef(Thread* self, ObjPtr\u003cmirror::Object\u003e obj) { // Check for null after decoding the object to handle cleared weak globals. if (obj == nullptr) { return nullptr; } IndirectRef ref; std::string error_msg; { WriterMutexLock mu(self, *Locks::jni_globals_lock_); ref = globals_.Add(kIRTFirstSegment, obj, \u0026error_msg); } if (UNLIKELY(ref == nullptr)) { LOG(FATAL) \u003c\u003c error_msg; UNREACHABLE(); } CheckGlobalRefAllocationTracking(); return reinterpret_cast\u003cjobject\u003e(ref); } // art/runtime/indirect_reference_table.cc IndirectRef IndirectReferenceTable::Add(IRTSegmentState previous_state, ObjPtr\u003cmirror::Object\u003e obj, std::string* error_msg) { size_t top_index = segment_state_.top_index; CHECK(obj ","date":"2018-12-25","objectID":"/binder-proxy-leak/:1:2","tags":["binder","mat","hprof"],"title":"system_server BinderProxy相关泄露问题记录","uri":"/binder-proxy-leak/"},{"categories":null,"content":"增加调试代码，输出BinderProxy详细信息 先看下打印global reference table的代码： // art/runtime/reference_table.cc void ReferenceTable::Dump(std::ostream\u0026 os, Table\u0026 entries) { // 打印最后使用的10个reference实际的类型 const size_t kLast = 10; size_t count = entries.size(); int first = count - kLast; if (first \u003c 0) { first = 0; } os \u003c\u003c \"Last \" \u003c\u003c (count - first) \u003c\u003c \"entries (of \" \u003c\u003c count \u003c\u003c \"):\\n\"; Runtime* runtime = Runtime::Current(); for (int idx = count - 1; idx \u003e= first; --idx) { ObjPtr\u003cmirror::Object\u003e ref = entries[idx].Read(); if (ref == nullptr) { continue; } if (runtime-\u003eIsClearedJniWeakGlobal(ref)) { os \u003c\u003c StringPrintf(\"%5d: cleared jweak\\n\", idx); continue; } if (ref-\u003eGetClass() == nullptr) { // should only be possible right after a plain dvmMalloc(). size_t size = ref-\u003eSizeOf(); os \u003c\u003c StringPrintf(\"%5d: %p (raw) (%zd bytes)\\n\", idx, ref.Ptr(), size); continue; } std::string className(ref-\u003ePrettyTypeOf()); std::string extras; size_t element_count = GetElementCount(ref); if (element_count != 0) { StringAppendF(\u0026extras, \"(%zd elements)\", element_count); } else if (ref-\u003eGetClass()-\u003eIsStringClass()) { ObjPtr\u003cmirror::String\u003e s = ref-\u003eAsString(); std::string utf8(s-\u003eToModifiedUtf8()); if (s-\u003eGetLength() \u003c= 16) { StringAppendF(\u0026extras, \"\\\"%s\\\"\", utf8.c_str()); } else { StringAppendF(\u0026extras, \"\\\"%.16s... (%d chars)\", utf8.c_str(), s-\u003eGetLength()); } } else if (ref-\u003eIsReferenceInstance()) { // 指向WeakReference/SoftReference/...对象，则打印被它引用对象类型 ObjPtr\u003cmirror::Object\u003e referent = ref-\u003eAsReference()-\u003eGetReferent(); if (referent == nullptr) { extras = \"(referent is null)\"; } else { extras = StringPrintf(\"(referent is a %s)\", referent-\u003ePrettyTypeOf().c_str()); } } ... // 统计每种类型的对象的数量 os \u003c\u003c \"Summary:\\n\"; for (SummaryElement\u0026 elem : sorted_summaries) { ObjPtr\u003cmirror::Object\u003e elemObj = elem.root.Read\u003ckWithoutReadBarrier\u003e(); DumpSummaryLine(os, elemObj, GetElementCount(elemObj), elem.identical, elem.equiv); } BinderProxy.getInterfaceDescriptor()方法，它返回一个描述其信息的字符串，所以只要在上面的代码判断下reference指向对象的类型，如果是BinderProxy的话，则顺便也输出下interfaceDescriptor，而如果是RemoteCallbackList$Callback类型的话，也是一样地输出其内部存储的callback对象的interfaceDescriptor： void ReferenceTable::Dump(std::ostream\u0026 os, Table\u0026 entries) { // 打印所有的reference const size_t kLast = 51200; ... std::string CALLBACK_STR = \"android.os.RemoteCallbackList$Callback\"; ScopedLocalRef\u003cjclass\u003e classbackClazz(env, env-\u003eFindClass(CALLBACK_STR.c_str())); jmethodID getCallbackInfo = env-\u003eGetMethodID(classbackClazz.get(), \"getCallbackInfo\", \"()Ljava/lang/String;\"); std::string BINDER_PROXY_TYPE = \"android.os.BinderProxy\"; ScopedLocalRef\u003cjclass\u003e binderProxyClazz(env, env-\u003eFindClass(BINDER_PROXY_TYPE.c_str())); jmethodID getInterfaceDescriptor = env-\u003eGetMethodID(binderProxyClazz.get(), \"getInterfaceDescriptorV2\", \"()Ljava/lang/String;\"); ... if (ref-\u003eIsReferenceInstance()) { // 指向WeakReference/SoftReference对象，则打印被它引用的对象类型 ObjPtr\u003cmirror::Object\u003e referent = ref-\u003eAsReference()-\u003eGetReferent(); if (referent == nullptr) { extras = \"(referent is null)\"; } else { extras = StringPrintf(\"(referent is a %s)\", referent-\u003ePrettyTypeOf().c_str()); if (referent-\u003ePrettyTypeOf() == BINDER_PROXY_TYPE) { ScopedLocalRef\u003cjobject\u003e binderProxy(env, env_ext-\u003eNewLocalRef(referent.Ptr())); ScopedLocalRef\u003cjstring\u003e descriptorStr(env, (jstring) (env-\u003eCallObjectMethod(binderProxy.get(), getInterfaceDescriptor))); if (descriptorStr.get() != nullptr) { const char* descriptorChars = nullptr; descriptorChars = env-\u003eGetStringUTFChars(descriptorStr.get(), nullptr); if(descriptorChars) { extras = StringPrintf(\"(referent is a %s) \", referent-\u003ePrettyTypeOf().c_str(), descriptorChars); env-\u003eReleaseStringUTFChars(descriptorStr.get(), descriptorChars); } } } } } else if (className == CALLBACK_STR) { ScopedLocalRef \u003cjobject\u003e callback(env, env_ext-\u003eNewLocalRef(ref.Ptr())); ScopedLocalRef \u003cjstring\u003e infoStr(env, (jstring)(env-\u003eCallObjectMethod(callback.get(), getCallbackInfo))); if (infoStr.get() != nullptr) { const char *descriptorChars = nullptr; descriptorChars = env-\u003eGetStringUTFChars(infoStr.get(), nu","date":"2018-12-25","objectID":"/binder-proxy-leak/:2:0","tags":["binder","mat","hprof"],"title":"system_server BinderProxy相关泄露问题记录","uri":"/binder-proxy-leak/"},{"categories":null,"content":"再调整 既然binderProxy对应的远端进程可能会挂掉，那么在远端进程调用system_server的接口，写Binder对象的时候，顺便把它的interfaceDescriptor写入Parcel，一并发送给system_system，然后system_server进程收到binder调用时，把远端app进程的写入的interfaceDescriptor从parcel里反序列化出来，塞进对应的BinderProxy即可。 考虑到system_server会或类似installd, sufaceflinger这类native进程进行binder call，所以像下面这样仅修改Parcel.java#writeStrongBinder()方法，还不够稳妥： public class Binder implements IBinder { public final void writeStrongBinder(IBinder val) { String desV2 = \"\"; if (val instanceof Binder) { desV2 = ((Binder)val).getInterfaceDescriptorV2(); } nativeWriteStrongBinder(mNativePtr, val); nativeWriteString(mNativePtr, desV2); } public final IBinder readStrongBinder() { IBinder iBinder = nativeReadStrongBinder(mNativePtr); String desV2 = nativeReadString(mNativePtr); if (iBinder instanceof BinderProxy) { ((BinderProxy)iBinder).descriptorV2 = desV2; } return iBinder; } 否则可能因为序列化/反序列化时对parcel读写不一致，引入不必要的稳定性问题，那么就得换个方式，改libbinder的底层实现，因为不管是java进程还是native进程实际都是使用的libbinder： // frameworks/base/core/jni/android_os_Parcel.cpp --static void android_os_Parcel_writeStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr, jobject object) ++static void android_os_Parcel_writeStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr, jobject object, jstring val) { Parcel* parcel = reinterpret_cast\u003cParcel*\u003e(nativePtr); if (parcel != NULL) { -- const status_t err = parcel-\u003ewriteStrongBinder(ibinderForJavaObject(env, object)); ++ String16 s16; ++ if (val) { ++ const jchar* str = env-\u003eGetStringCritical(val, 0); ++ if (str) { ++ s16 = String16(reinterpret_cast\u003cconst char16_t*\u003e(str), env-\u003eGetStringLength(val)); ++ env-\u003eReleaseStringCritical(val, str); ++ } ++ } ++ const status_t err = parcel-\u003ewriteStrongBinderV2(ibinderForJavaObject(env, object), s16); if (err != NO_ERROR) { signalExceptionForError(env, clazz, err); } } } --static jobject android_os_Parcel_readStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr) ++static jobject android_os_Parcel_readStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr, jobjectArray stringArray) { Parcel* parcel = reinterpret_cast\u003cParcel*\u003e(nativePtr); if (parcel != NULL) { -- return javaObjectForIBinder(env, parcel-\u003ereadStrongBinder()); ++ String16 out; ++ jobject obj = javaObjectForIBinder(env, parcel-\u003ereadStrongBinderV2(\u0026out)); ++ if (out.size() \u003e 0) { ++ int stringCount = env-\u003eGetArrayLength(stringArray); ++ if (stringCount \u003e 0) { ++ jstring str = env-\u003eNewString(reinterpret_cast\u003cconst jchar*\u003e(out.string()), out.size()); ++ env-\u003eSetObjectArrayElement(stringArray, 0, str); ++ } ++ } ++ return obj; } return NULL; } // ---------------------------------------------------------------------------- static const JNINativeMethod gParcelMethods[] = { -- {\"nativeWriteStrongBinder\", \"(JLandroid/os/IBinder;)V\", (void*)android_os_Parcel_writeStrongBinder}, ++ {\"nativeWriteStrongBinder\", \"(JLandroid/os/IBinder;Ljava/lang/String;)V\", (void*)android_os_Parcel_writeStrongBinder}, ... -- {\"nativeReadStrongBinder\", \"(J)Landroid/os/IBinder;\", (void*)android_os_Parcel_readStrongBinder}, ++ {\"nativeReadStrongBinder\", \"(J[Ljava/lang/String;)Landroid/os/IBinder;\", (void*)android_os_Parcel_readStrongBinder}, // frameworks/native/libs/binder/Parcel.cpp sp\u003cIBinder\u003e Parcel::readStrongBinderV2(String16* outDescriptor) const { sp\u003cIBinder\u003e val; readNullableStrongBinder(\u0026val, outDescriptor); return val; } status_t Parcel::writeStrongBinderV2(const sp\u003cIBinder\u003e\u0026 val, const String16\u0026 descritorV2) { return flatten_binder(ProcessState::self(), val, this, descritorV2); } status_t unflatten_binder(const sp\u003cProcessState\u003e\u0026 proc, const Parcel\u0026 in, sp\u003cIBinder\u003e* out, String16* outDescriptor) { const flat_binder_object* flat = in.readObject(false); if (flat) { if (outDescriptor) in.readString16(outDescriptor); else in.readString16(); switch (flat-\u003ehdr.type) { case BINDER_TYPE_BINDER: *out = reinterpret_cast\u003cIBinder*\u003e(flat-\u003ecookie); return finish_unflatten_binder(NULL, *flat, in); case BINDER_TYPE_HANDLE: *out = proc-\u003egetStrongProxyForHandle(flat-\u003ehandle); return finish_unflatten","date":"2018-12-25","objectID":"/binder-proxy-leak/:2:1","tags":["binder","mat","hprof"],"title":"system_server BinderProxy相关泄露问题记录","uri":"/binder-proxy-leak/"},{"categories":null,"content":"定位泄漏点 重新打包后，压测跑到6000多次，就复现了这个问题，查看转储到dropbox里的global reference table文件： BinderProxy diagnosis: total size of 21762 BinderProxy descriptor histogram (top 100): #1: \u003ccleared weak-ref\u003e x128 #2: unknown x48 #3: com.android.bluetooth-u1002-p4845-android.bluetooth.IBluetoothHeadset@dbb6c2b x3 #4: com.android.bluetooth-u1002-p19850-android.bluetooth.IBluetoothHeadset@dbb6c2b x3 #5: com.android.bluetooth-u1002-p30548-android.bluetooth.IBluetoothHeadset@dbb6c2b x3 #6: com.android.bluetooth-u1002-p10107-android.bluetooth.IBluetoothHeadset@e035221 x3 #7: com.android.bluetooth-u1002-p8648-android.bluetooth.IBluetoothHeadset@dbb6c2b x3 #8: com.android.bluetooth-u1002-p27012-android.bluetooth.IBluetoothHeadset@dbb6c2b x3 #9: com.android.bluetooth-u1002-p2900-android.bluetooth.IBluetoothHeadset@dbb6c2b x3 #10: com.android.bluetooth-u1002-p12192-android.bluetooth.IBluetoothHeadset@dbb6c2b x2 #11: com.android.bluetooth-u1002-p20034-android.bluetooth.IBluetoothHidDevice@5c0c317 x2 #12: com.android.bluetooth-u1002-p9279-android.bluetooth.IBluetoothHeadset@dbb6c2b x2 ... Per Uid Binder Proxy Counts: UID : 1000 count = 718 UID : 1001 count = 194 UID : 1002 count = 20262 // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c UID : 1027 count = 21 都是指向蓝牙（uid=1002）进程的BinderProxy，同时我在系统crash前也打印了system_server挂掉前的heap profile，所以接下来先借助下Eclipse MAT来统计下所有的BinderProxy 注：android上通过Debug.dumpHprofData()接口dump下来的hprof文件需要用hprof-con工具手动转一下才能由MAT打开，这个工具位于你下载的android sdk目录，见${android-sdk}/platform-tools/hprof-conv 展开所有的entry后，点击工具栏的\"导出\"按钮，再由shell命令排序好后，得到： BinderProxy 数量 android.bluetooth.IBluetoothHeadset 6583 android.bluetooth.IBluetoothHidDevice 6518 miui.process.IMiuiApplicationThread 6048 挑选一个interfaceDescriptor是蓝牙进程的IMiuiApplicationThread的BinderProxy的实例： SELECT * FROM android.os.BinderProxy s where toString(s.descriptorV2.value) = \"com.android.bluetooth-u1002-p304-miui.process.IMiuiApplicationThread@c01e15e\" 有泄漏，即它没有被虚拟机回收，那么必定就有\u003e=1的gc 跟节点还（直接或间接）持有这个被泄露的对象的引用，所以再借助MAT来分析有哪些gc根节点指向这个被泄露的对象： 可以看到这个BinderProxy是被mMiuiApplicationThreads这个SparseArray强引用着，mMiuiApplicationThreads又是被mMiuiApplicationThreadManager引用，它是mMiuiApplicationThreadManager定义在ProcessManagerService.java里mMiuiApplicationThreads这个SparseArray的size是 6143！。 结合代码发现了每个进程的启动的时候会向system_server注册一个descriptor为IMiuiApplicationThread的BinderProxy对象，主要用于MIUI的长截屏功能而在进程挂掉的时候，却没有从移除掉，所以就发生泄漏，详细代码枯燥，此处略，这一块属于进程管理相关的，直接通知相关同学进行修复了。 继续定位剩余两个泄漏项，流程跟定位IMiuiApplicationThread泄漏的是一样的： 1、标定一个泄漏的BinderProxy 2、查看它的gc roots 可以看到它被ProcessRecord.connections这个ArraySet引用着，那么下面再看下这个ProcessRecord是表示的哪个进程： 最后得到： 原来是system_server进程的ProcessRecord的问题，注意看connections.mArray的大小，有7749个! 3、确认代码逻辑： 翻看下对ProcessRecord.connections进行增删的地方，只有binderService和unbindService 到这里我们就可以判定肯定是system_server某个地方有重复绑定IBluetoothHeadset这个代表的service了，去package/apps/bluetooth目录下确认这个类是HeadsetService.java了，最终定位到BluetoothManagerService.java类里确实存在重复bind的情况，具体代码略，另外还确认到BluetoothHidDevice.java逻辑也存在问题，导致压力测试中systemui和com.xiaomi.bluetooth会出现重复bind的情况，已经跟蓝牙同事沟通，由他们进行修复并提交给aosp。 ","date":"2018-12-25","objectID":"/binder-proxy-leak/:3:0","tags":["binder","mat","hprof"],"title":"system_server BinderProxy相关泄露问题记录","uri":"/binder-proxy-leak/"},{"categories":null,"content":"继续调查global reference overflow问题 在上面的问题都修复后，9.0上依然有global reference overflow问题，继续测试后确认是桌面频繁调用壁纸接口导致，根本原因是RemoteCallbackList.register方法实现存在问题下面这段代码可以很容易的制造出这个问题： void testGetCurrentWallpaper() { WallpaperManager manager = WallpaperManager.getInstance(this); int count = 0; while (true) { count++; BitmapDrawable drawable = null; if ((drawable = (BitmapDrawable) manager.getDrawable()) == null) { Log.d(\"WWW\", \"failed to get wallpaper: seq=\" + count); } else { Log.d(\"WWW\", \"got wallpaper: seq=\" + count); // deprecate cahce drawable.getBitmap().recycle(); } } } 提交了修复patch给aosp，这类小概率问题google的研发一般处理的都不会太积极 public boolean register(E callback, Object cookie) { synchronized (mCallbacks) { IBinder binder = callback.asBinder(); try { Callback cb = new Callback(callback, cookie); binder.linkToDeath(cb, 0); mCallbacks.put(binder, cb); Callback oldDeathRecipient = mCallbacks.put(binder, cb); if (oldDeathRecipient != null) { removeRegistration(oldDeathRecipient); try { // Global reference would overflow if the same callback was // registered repeatedly binder.unlinkToDeath(oldDeathRecipient, 0); } catch (NoSuchElementException e) { // Should not happen Slog.d(TAG, \"Failed to unregister \" + oldDeathRecipient); } } return true; } catch (RemoteException e) { return false; } } } ","date":"2018-12-25","objectID":"/binder-proxy-leak/:4:0","tags":["binder","mat","hprof"],"title":"system_server BinderProxy相关泄露问题记录","uri":"/binder-proxy-leak/"},{"categories":null,"content":"小结： 内存泄露问题，平时一般都不会太关注，如果是app开发还好点，集成一下leakcannary这类工具，可以做到自动分析activity这类泄露，基本上能把潜在的泄露在外发前就解决掉；但system_server进程有点特殊，除非发生OTA，用户手动重启手机这种情况，它是一直在后台运行的，哪怕有一点泄露，也经不住几周或几个月的累积，积累到一定程度了，就是系统卡顿，app频繁被杀，最终异常重启，影响用户口碑。 ","date":"2018-12-25","objectID":"/binder-proxy-leak/:5:0","tags":["binder","mat","hprof"],"title":"system_server BinderProxy相关泄露问题记录","uri":"/binder-proxy-leak/"},{"categories":null,"content":"本文介绍Android PackageManagerService对应用权限的管理 ","date":"2018-03-07","objectID":"/pkms-permission/:0:0","tags":["pkms","permission"],"title":"Android PKMS 权限管理介绍","uri":"/pkms-permission/"},{"categories":null,"content":"应用安装时PKMS对权限的处理 先回顾下app安装流程： → installPackageLI（安装app，入口函数） → installNewPackageLI（安装一个全新的app，即以前未安装过） → parsePackage (解析AndroidManifest.xml：构建Activity/Service/ContentProvider/BroadcastReceiver运行时对象...) → scanPackageLI (收集证书/校验签名，dex2oat优化，创建app数据目录，释放so文件，分类规整四大组件...) → updateSettingsLI（更新/持久化app信息） → updatePermissionsLPw（更新权限信息，例如移除一些已经不存在的系统或app自定义的权限） → grantPermissionsLPw（授予app申请的权限） → （发送package add/change广播） 结束 // 文件位置：frameworks/base/service/core/java/com/android/server/pm/PackageManagerService.java private void grantPermissionsLPw(PackageParser.Package pkg, boolean replace, String packageOfInterest) { final PackageSetting ps = (PackageSetting) pkg.mExtras; final GrantedPermissions gp = ps.sharedUser != null ? ps.sharedUser : ps; ArraySet\u003cString\u003e origPermissions = gp.grantedPermissions; boolean changedPermission = false; final int N = pkg.requestedPermissions.size(); for (int i=0; i\u003cN; i++) { final String name = pkg.requestedPermissions.get(i); final boolean required = pkg.requestedPermissionsRequired.get(i); final BasePermission bp = mSettings.mPermissions.get(name); final String perm = bp.name; boolean allowed; boolean allowedSig = false; ... final int level = bp.protectionLevel \u0026 PermissionInfo.PROTECTION_MASK_BASE; if (level == PermissionInfo.PROTECTION_NORMAL || level == PermissionInfo.PROTECTION_DANGEROUS) { allowed = (required || origPermissions.contains(perm) // 必须的(即AndroidManifest里没有手动声明required=false) or 之前的版本已经拥有该权限 or 咩有自升级过的系统app || (isSystemApp(ps) \u0026\u0026 !isUpdatedSystemApp(ps))); } else if (bp.packageSetting == null) { // This permission is invalid; skip it. allowed = false; } else if (level == PermissionInfo.PROTECTION_SIGNATURE) { // 如果app申请的权限是签名级保护的， allowed = grantSignaturePermission(perm, pkg, bp, origPermissions); // 则需要校验定义该权限的app与当前这个app的签名是否相同 if (allowed) { allowedSig = true; } } else { allowed = false; } if (allowed) { ... if (!gp.grantedPermissions.contains(perm)) { changedPermission = true; gp.grantedPermissions.add(perm); // 更新该app已获取到的权限列表 gp.gids = appendInts(gp.gids, bp.gids); // 更新该app可以加入的gid } else if (!ps.haveGids) { gp.gids = appendInts(gp.gids, bp.gids); } } else { if (gp.grantedPermissions.remove(perm)) { changedPermission = true; gp.gids = removeInts(gp.gids, bp.gids); // revoke此项权限 } ... } 因为不管是安装一个全新的app，还是更新一个已安装的app，最后都会调用到grantPermissionsLPw这个方法， 这个方法逻辑其实较简洁，就是遍历新app中声明的权限列表，更新已有的权限列表，和gid数组，删除掉已经不再需要的权限和gid 另外可以参考下面三个文件，： 文件 功能 android/os/Process.java#getGidForName(name) 根据gid名称查询gid value /frameworks/base/data/etc/platform.xml 定义权限名称 与 gid 名称的映射关系 /system/core/…/android_filesystem_config.h 定义uid/gid名称和值的映射 接着，再看下校验app是否拥有某项权限的流程: 这一步也很简单，如果调用方是个普通app的话，只要检查下这个app的已授予的权限列表里不是包含请求的权限即可；如果调用方是media，cameraserver，audioserver这类系统用户的话，他们的权限是预先就定好的，参考/frameworks/base/data/etc/platform.xml，开机时会解析到mSystemPermissions这个map里，所以这时便可直接从这个map里拿到对应uid拥有的权限列表，如果包含了参数permName，则uid拥有了这个权限；反之，则表明该uid无此权限。 // 文件位置：frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java public int checkUidPermission(String permName, int uid) { synchronized (mPackages) { Object obj = mSettings.getUserIdLPr(UserHandle.getAppId(uid)); if (obj != null) { GrantedPermissions gp = (GrantedPermissions)obj; if (gp.grantedPermissions.contains(permName)) { return PackageManager.PERMISSION_GRANTED; } } else { HashSet\u003cString\u003e perms = mSystemPermissions.get(uid); if (perms != null \u0026\u0026 perms.contains(permName)) { return PackageManager.PERMISSION_GRANTED; } } } return PackageManager.PERMISSION_DENIED; } 从上面的代码可以看到，AMS在创建app进程的时候，将app拥有的gids给一并传递给了zygote进程，等zygote fork出子进程后，会通过setgroups系统调用把传过来的gids设置到新的进程上，于是这个新的进程就获得了相应的权限。 ","date":"2018-03-07","objectID":"/pkms-permission/:0:1","tags":["pkms","permission"],"title":"Android PKMS 权限管理介绍","uri":"/pkms-permission/"},{"categories":null,"content":"其他类型的权限 除了基于gid实现的权限控制，还有很多其他的权限的控制，Android没有通过gid来控制，而是让这些权限的owner自己去检验调用方app是否已经被系统授予了这类权限，例如下面获取地理位置信息和打开相机这两个例子； ","date":"2018-03-07","objectID":"/pkms-permission/:0:2","tags":["pkms","permission"],"title":"Android PKMS 权限管理介绍","uri":"/pkms-permission/"},{"categories":null,"content":"案例1，获取地理位置过程中权限的校验过程 1）通过gps拿到地理位置信息 public void getLastKnownGpsLocation() { LocationManager lm = (LocationManager) getApplicationContext().getSystemService(LOCATION_SERVICE); Location location = lm.getLastKnownLocation(LocationManager.GPS_PROVIDER); } 2）ipc进入system_server进程，调用LocationManagerService的getLastLocation() // frameworks/base/location/java/android/location/LocationManager.java public Location getLastKnownLocation(String provider) { checkProvider(provider); String packageName = mContext.getPackageName(); LocationRequest request = LocationRequest.createFromDeprecatedProvider( provider, 0, 0, true); try { return mService.getLastLocation(request, packageName); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } LocationManagerService.getLastLocation()首先会验证调用方是否拥有访问位置信息的权限，最终调用到 文章一开始介绍的PKMS.checkUidPermission()方法，进行校验，如果调用方app的确拥有此权限，那么就会进行后续流程，并最终返回gps位置给调用方；否则，就直接返回null。 // frameworks/base/services/core/java/com/android/server/LocationManagerService.java @Override public Location getLastLocation(LocationRequest request, String packageName) { ... final int pid = Binder.getCallingPid(); final int uid = Binder.getCallingUid(); final long identity = Binder.clearCallingIdentity(); try { ... if (!reportLocationAccessNoThrow(pid, uid, packageName, allowedResolutionLevel)) { if (D) Log.d(TAG, \"not returning last loc for no op app: \" + packageName); return null; } ... } boolean reportLocationAccessNoThrow( int pid, int uid, String packageName, int allowedResolutionLevel) { ... if (getAllowedResolutionLevel(pid, uid) \u003c allowedResolutionLevel) { return false; } return true; } private int getAllowedResolutionLevel(int pid, int uid) { if (mContext.checkPermission(android.Manifest.permission.ACCESS_FINE_LOCATION, pid, uid) == PackageManager.PERMISSION_GRANTED) { return RESOLUTION_LEVEL_FINE; } else if (mContext.checkPermission(android.Manifest.permission.ACCESS_COARSE_LOCATION, pid, uid) == PackageManager.PERMISSION_GRANTED) { return RESOLUTION_LEVEL_COARSE; } else { return RESOLUTION_LEVEL_NONE; } } ContextImpl.checkPermission() → AMS.checkPermission() → AMS.checkComponentPermission() → PKMS.checkUidPermission() 这一系列调用实现都比较简单，不再赘述。 ","date":"2018-03-07","objectID":"/pkms-permission/:0:3","tags":["pkms","permission"],"title":"Android PKMS 权限管理介绍","uri":"/pkms-permission/"},{"categories":null,"content":"案例2，打开相机 1）Camera.open()的调用流程 → Camera.open() // frameworks/base/core/java/android/hardware/Camera.java → android_hardware_Camera_native_setup() // frameworks/base/core/jni/android_hardware_Camera.cpp → Camera::connect() // frameworks/av/camera/Camera.cpp → CameraBase::connect() // frameworks/av/camera/CameraBase.cpp → BpCameraService::connect() // frameworks/av/camera/ICameraService.cpp → BpBinder.transact() // frameworks/native/libs/binder/BpBinder.cpp → CameraService.onTransact() // frameworks/av/services/camera/libcameraservice/CameraService.cpp status_t CameraService::onTransact(uint32_t code, const Parcel\u0026 data, Parcel* reply, uint32_t flags) { // Permission checks switch (code) { case BnCameraService::CONNECT: case BnCameraService::CONNECT_PRO: case BnCameraService::CONNECT_DEVICE: case BnCameraService::CONNECT_LEGACY: const int pid = getCallingPid(); const int self_pid = getpid(); if (pid != self_pid) { // 校验调用方是否拥有打开相机的权限 if (!checkCallingPermission(String16(\"android.permission.CAMERA\"))) { return PERMISSION_DENIED; } } ... } 从上面代码可看到，只有调用方app拥有了打开相机的权限，才会进行后续的初始化操作，否则就直接返回了。 // frameworks/native/libs/binder/IServiceManager.cpp static String16 _permission(\"permission\"); bool checkPermission(const String16\u0026 permission, pid_t pid, uid_t uid) { if (pc != NULL) { // ipc调用system_server的PermissionController服务进行校验 bool res = pc-\u003echeckPermission(permission, pid, uid); if (res) { return res; } ... } // 获取PermissionController的binderProxy对象 sp\u003cIBinder\u003e binder = defaultServiceManager()-\u003echeckService(_permission); pc = interface_cast\u003cIPermissionController\u003e(binder); } 先获取PermissionController的binder proxy对象，然后ipc最终调用到前面提到的PackManagerService.checkUidPermission方法中。 // frameworks/base/core/java/com/android/server/am/ActivityManagerService.java public void setSystemProcess() { try { ServiceManager.addService(\"permission\", new PermissionController(this)); ... } static class PermissionController extends IPermissionController.Stub { @Override public boolean checkPermission(String permission, int pid, int uid) { return mActivityManagerService.checkPermission(permission, pid, uid) == PackageManager.PERMISSION_GRANTED; } } AMS.checkPermission() → AMS.checkComponentPermission() → ActivityManager.chceckComponentPersission() → PKMS.checkUidPermission() ","date":"2018-03-07","objectID":"/pkms-permission/:0:4","tags":["pkms","permission"],"title":"Android PKMS 权限管理介绍","uri":"/pkms-permission/"},{"categories":null,"content":"Android 6.0+的变化 Android 6.0开始引入运行时权限的概念，将系统权限分成了Normal和Dangerous两个大类，其中 Normal权限包含了网络，震动，NFC，指纹，传感器等等，Dangerous权限包含了读写外置存储，打开相机，蓝牙，定位，短信，电话，联系人等等; 对于Dangerous类的权限，也叫做运行时权限，不会再像以前版本那样安装时系统直接授予app，而是后面使用过程中让用户自己选择是否要授予app这类权限； 而对于Normal类的权限，跟6.0前的版本上保持一致，只要app的Manifest里声明了权限，在安装的时候便会授予。 这个新feature给开发者带来一些麻烦，就是每次要使用到危险类的权限时，例如打开相机，开启录音时，都需要先检查自己的app是否拥有了，如果没有就要先请求用户授权，然后才能继续。 ","date":"2018-03-07","objectID":"/pkms-permission/:1:0","tags":["pkms","permission"],"title":"Android PKMS 权限管理介绍","uri":"/pkms-permission/"},{"categories":null,"content":"检查app是否拥有某些权限 通过Context.checkSelfPermission(String permission)可以查询到调用方app是否被被用户授予了参数permission，这个方法也是通过ipc最终调用到system_server进程的PackageManagerService.checkUidPermission()方法进行实际的校验工作. ","date":"2018-03-07","objectID":"/pkms-permission/:1:1","tags":["pkms","permission"],"title":"Android PKMS 权限管理介绍","uri":"/pkms-permission/"},{"categories":null,"content":"请求用户授权 通过Activity.requestPermissions(String[] permissions, int requestCode)请求用户授予参数permissions列表，系统会弹出下图所示的弹框，让用户选择允许或拒绝申请的权限： 当用户选择了拒绝或者允许后，在Activity.onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults）会接受到用户选择的的结果； 请注意上图里面的个\"Nerver ask again\"选项，如果用户勾选了它，并且点击拒绝按钮，那么后面再调用Activity.requestPermissions()系统就不会再弹出这个框，让用户选择了，而是直接就回调Activity.onRequestPermissionsResult()，参数grantResults里的值全部为PERMISSION_DENIED，framework针对这种情况也提供了Activity.shouldShowRequestPermissionRationale(String permission)这个接口，如果用户之前有拒绝过app请求的这个权限，那么会返回true，此时app再申请相同的权限的时可以先显示一个UI，跟用户解释一下需要这个权限的原因，然后再调用Activity.requestPermissions()接口，弹出上图里的对话框； 如果之前没有申请过这个权限，或者以前申请过并被用户授予了，但是用户后面又在系统设置里收回了这个权限，那么这个接口返回的是false；但是，如果用户之前有选择拒绝，并且勾选了\"Nerever ask again\"选项的话，shouldShowRequestPermissionRationale()接口返回的就是false了，这时候就比较尴尬了，因为你无法区分之前是不是有申请过这个权限，并且被用户决绝过了 ，只能直接调用Activity.requestPermissions()接口，然后在系统返回请求结果的回调方法里才能了解到用户拒绝了这个权限，并且已经勾选了\"Never ask again\"选项（因为没有弹出上图里的弹框）-_-||，下次再请求的时候就可以先显示一个解释说明的UI，引导用户去勾选要的权限，再帮用户导航到系统设置界面，让用户去操作。 ","date":"2018-03-07","objectID":"/pkms-permission/:1:2","tags":["pkms","permission"],"title":"Android PKMS 权限管理介绍","uri":"/pkms-permission/"},{"categories":null,"content":"案例分析：app运行期间，系统如何实现赋予和回收读写sd卡的权限？ 6.0以前，sd卡文件读写是通过用户组来实现的，6.0上这个权限变成了运行时权限，那系统是如何实现不重启app进程的情况下赋予它读写sd卡文件权限的呢？ 当授予一个app读写sd文件权限的时候，大致是下面这个调用流程： // SystmServer进程 → PackageManagerService.grantRuntimePermission() → StorageManagerService.onExternalStoragePolicyChanged() → remountUidExternalStorage() → NativeDaemonConnector.execute(“remote_uid”) // vold进程 → SocketListener::runListener() → FrameworkListener::onDataAvailable() → FrameworkListener::dispatchCommand() → CommandListener::VolumeCmd::runCommand() → VolumeManager::remountUid() 跳过中间步骤，直接看下remountUid()函数的实现: // system/vold/VolumeManager.cpp int VolumeManager::remountUid(uid_t uid, const std::string\u0026 mode) { LOG(DEBUG) \u003c\u003c \"Remounting \" \u003c\u003c uid \u003c\u003c \"as mode \" \u003c\u003c mode; DIR* dir; struct dirent* de; char rootName[PATH_MAX]; char pidName[PATH_MAX]; int pidFd; int nsFd; struct stat sb; pid_t child; if (!(dir = opendir(\"/proc\"))) { PLOG(ERROR) \u003c\u003c \"Failed to opendir\"; return -1; } // Poke through all running PIDs look for apps running as UID while ((de = readdir(dir))) { pidFd = -1; nsFd = -1; pidFd = openat(dirfd(dir), de-\u003ed_name, O_RDONLY | O_DIRECTORY | O_CLOEXEC); ... // // We purposefully leave the namespace open across the fork nsFd = openat(pidFd, \"ns/mnt\", O_RDONLY); // not O_CLOEXEC if (!(child = fork())) { // fork一个子vold进程 // 把新fork出的vold进程加入nsFd所指的mount namespace， // 便于让uid下的进程和这个子vold进程可以共享(mount/unmount)挂载点 if (setns(nsFd, CLONE_NEWNS) != 0) { _exit(1); } unmount_tree(\"/storage\"); // 卸载当前的/storage挂载点 std::string storageSource; if (mode == \"default\") { storageSource = \"/mnt/runtime/default\"; // sdcard_rw组用户可读写，owner为root } else if (mode == \"read\") { storageSource = \"/mnt/runtime/read\"; // 所有用户可读，owner为root } else if (mode == \"write\") { storageSource = \"/mnt/runtime/write\"; // 所有用户可读写，owner为root } // 绑定/storage到/mnt/runtime/xxxx目录上，即拥有相同的inode // 然后在/storage上就可以看见/mnt/runtime/xxx/目录里的文件了 if (TEMP_FAILURE_RETRY(mount(storageSource.c_str(), \"/storage\", NULL, MS_BIND | MS_REC, NULL)) == -1) { _exit(1); } // 给/storage设置slave标识后，当插上外置存储卡时，绑定到这个目录的其他挂载点 // 也可以看到/storage下新挂载的存储 if (TEMP_FAILURE_RETRY(mount(NULL, \"/storage\", NULL, MS_REC | MS_SLAVE, NULL)) == -1) { _exit(1); } // Mount user-specific symlink helper into place userid_t user_id = multiuser_get_user_id(uid); std::string userSource(StringPrintf(\"/mnt/user/%d\", user_id)); // 绑定/storage/self到/mnt/user/{userid}上，即拥有相同的inode // 然后就可以在/storage/self/下访问/mnt/user/{userid}/里的文件 if (TEMP_FAILURE_RETRY(mount(userSource.c_str(), \"/storage/self\", NULL, MS_BIND, NULL)) == -1) { _exit(1); } _exit(0); // 子vold进程使命完成，退出 } ... // 等待子vold进程结束，错误处理... } 这个函数中，首先遍历/proc目录，找到所有属于参数uid的app进程，依次执行，为了更好的说明问题，这儿用微信作为例子： vold进程先fork自身，再新fork出来到vold子进程里，执行setns()调用把自身与微信进程绑定，以共享mount namespace； 在vold子进程里，卸载掉当前挂载到/storage目录下的磁盘分区(或普通文件目录)，由于跟微信进程共享了mount ns，所以微信进程下也能够看到/storage变成了空目录； 依然在vold子进程里，根据传入的参数mode，如果用户同意了微信申请磁盘读写权限的请求，那么就会把/storage绑定到/mnt/runtime/write目录上；（而如果是用户在系统设置app里，收回了微信app读写外置存储的的权限，那么ActivityManager会直接结束掉所有微信进程，当走到remountUid的时候，因为没有存活的微信进程了，所以此时remountUid啥都不用做） 由于Android的多用户机制，要让微信进程正确的看到/sdcard/目录，还需做些额外的操作，先了解下/sdcard目录本身其实是个软链接，指向路径如下： /sdcard (symbolic link)→ /storage/self/primary (symbolic link) 第3步中vold子进程已经相应的给app进程重新挂载好了/storage目录，授予权限是相对于当前用户的，app进程访问的/sdcard目录是也相对与当前用户(userid)的，比如要让默认用户0下的微信进程可以访问到正确的sd卡文件，需要重新绑定/storage/self/目录到/mnt/user/0/上，再看下/sdcard/整个链接路径: /sdcard → /storage/self/primary → /mnt/user/0/primary → /storage/emulated/0 (mount bind) → /mnt/runtime/write/emulated/0， 于是/sdcard目录就正确的指向了/mnt/runtime/write/emulated/0目录，即微信进程拥有了读写/sdcard/的权限 参考：Namespaces in operation ","date":"2018-03-07","objectID":"/pkms-permission/:1:3","tags":["pkms","permission"],"title":"Android PKMS 权限管理介绍","uri":"/pkms-permission/"},{"categories":null,"content":"Instant App中文翻译即“免安装应用”，当点击一个链接时，类似6.0上引入的App Links功能，但更加强大的是，即便用户还没有安装对应的应，也可以直接打相应的应用，从而可以无缝体验原生应用。 ","date":"2018-01-18","objectID":"/instant-app/:0:0","tags":["instant_app","pkms"],"title":"Android Instant App简介","uri":"/instant-app/"},{"categories":null,"content":"如何体验Instant App 在nexus或pixel 8.0+设备上登录google帐号，进入设置 → Google → Instant apps → 选中之前登录的google帐号 → 系统弹出相关使用协议对话框 → 点击同意 进入chrome, 使用google 搜索 jet（试了下andorid官网说的几个instant app，竟然没有一个可以用的），点击有’instant‘标注的链接，参考下图： 稍等片刻(网速慢的话会先出现下左图的进度条)，即可进入jet应用（可能不支持大陆地区，这时候你得更新google账户的地区，在Play Store里绑定一个支持visa的信用卡即可） ","date":"2018-01-18","objectID":"/instant-app/:1:0","tags":["instant_app","pkms"],"title":"Android Instant App简介","uri":"/instant-app/"},{"categories":null,"content":"如何开发Instant App 请参考 Getting started with Android Instant Apps，android studio 3.0支持良好，此处略 ","date":"2018-01-18","objectID":"/instant-app/:2:0","tags":["instant_app","pkms"],"title":"Android Instant App简介","uri":"/instant-app/"},{"categories":null,"content":"Framework的实现 ","date":"2018-01-18","objectID":"/instant-app/:3:0","tags":["instant_app","pkms"],"title":"Android Instant App简介","uri":"/instant-app/"},{"categories":null,"content":"安装流程 在resolveIntent()的地方加了一个断点，然后点击那个带有instant标注的链接，这时chrome没有直接处理这个url，而是把你点击的链接封装成一个intent，通过startActivityIfNeed()调用让系统负责处理它 点击evaluate expression那个按钮(上图第一行最后一个按钮)，执行Binder.getCallingUid()可以获取到对端进程的uid为10017，然后通过getPackagesForUid(uid)也可以确认调用就是chrome $ adb shell dumpsys package com.android.chrome Packages: Package [com.android.chrome] (85fb650): userId=10017 pkg=Package{bfce98e com.android.chrome} codePath=/data/app/com.android.chrome--q5-0Pq30E_mdBwuC9yI9Q== ... 这时，系统会额外执行一些验证流程（TL;DR;）后，然后发现这个url是有对应的instant app可以使用的，于是就返回EphemeralInstallerActivity给调用方，最终打开它来下载和安装相应的instant app，参考： private void setUpInstantAppInstallerActivityLP(ActivityInfo installerActivity) { ... // Set up information for ephemeral installer activity mInstantAppInstallerActivity = installerActivity; mInstantAppInstallerActivity.flags |= ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS | ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS; mInstantAppInstallerActivity.exported = true; mInstantAppInstallerActivity.enabled = true; mInstantAppInstallerInfo.activityInfo = mInstantAppInstallerActivity; mInstantAppInstallerInfo.priority = 0; mInstantAppInstallerInfo.preferredOrder = 1; // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c 一般其他app的都为0 mInstantAppInstallerInfo.isDefault = true; mInstantAppInstallerInfo.match = IntentFilter.MATCH_CATEGORY_SCHEME_SPECIFIC_PART | IntentFilter.MATCH_ADJUSTMENT_NORMAL; } private ResolveInfo chooseBestActivity(Intent intent, String resolvedType, int flags, List\u003cResolveInfo\u003e query, int userId) { if (query != null) { final int N = query.size(); if (N == 1) { return query.get(0); } else if (N \u003e 1) { final boolean debug = ((intent.getFlags() \u0026 Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0); // If there is more than one activity with the same priority, // then let the user decide between them. // If the first activity has a higher priority, or a different // default, then it is always desirable to pick it. if (r0.priority != r1.priority || r0.preferredOrder != r1.preferredOrder // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c hit || r0.isDefault != r1.isDefault) { return query.get(0); } ... } 01-12 07:24:11.657 813-2282/system_process I/ActivityManager: START u0 {act=android.intent.action.VIEW cat=[android.intent.category.BROWSABLE] dat=https://jet.com/... flg=0x1c080000 cmp=com.android.vending/com.google.android.finsky.instantapps.EphemeralInstallerActivity (has extras)} from uid 10017 (可以看到调用方是google chrome) // google playstore的AndroidManifest.xml \u003cactivity finsky:name=\"com.google.android.finsky.instantapps.EphemeralInstallerActivity\" finsky:process=\":instant_app_installer\" finsky:taskAffinity=\":instant_app_installer\" finsky:launchMode=\"singleInstance\" \u003e \u003cintent-filter\u003e \u003caction finsky:name=\"android.intent.action.INSTALL_INSTANT_APP_PACKAGE\" /\u003e \u003ccategory finsky:name=\"android.intent.category.DEFAULT\" /\u003e \u003cdata finsky:scheme=\"file\" /\u003e \u003cdata finsky:mimeType=\"application/vnd.android.package-archive\" /\u003e \u003c/intent-filter\u003e \u003c/activity\u003e ","date":"2018-01-18","objectID":"/instant-app/:3:1","tags":["instant_app","pkms"],"title":"Android Instant App简介","uri":"/instant-app/"},{"categories":null,"content":"instant app的安装代码实现与PackageInstallerActivity基本相同，都是： 通过**PackageManager.getPackageInstaller()**获取到PckageInstanllerService的binder proxy对象， 通过 openSesstion() 这个binder call到system server端的PackageInstallerService，PackageInstallerService负责创建一个PackageInstallerSession这个binder实例，并返回 通过获取到的IpackageInstallerSesstion这个binder proxy再通过 openWrite() 让服务端创建一个socket pair，并拿到对应的client socket的文件描述符(fd)，接着就是通过这个socket fd 把intant app的apk文件写入到system server端，system server端会负责接受文件流，并写入到/data/app/下的一个临时文件里； 接下来就是走完PackageManagerServerice的installPackage流程，这里相比普通app有会几点不同： instant app不能安装在外置存储上 target sdk version 需8.0+，target sandbox version 需2+ 安装时不进行dex2oat操作（避免安装时间太长，影响体验），bg dexopt服务也不会对它做优化（存活时间可能比较短，没必要优化） 不能自定义权限(组) 不能用instant app替换已存在的相同包名的非instant app版本（反过来是可以） 磁盘空间不足时，instant app可能会被移除掉 ","date":"2018-01-18","objectID":"/instant-app/:3:2","tags":["instant_app","pkms"],"title":"Android Instant App简介","uri":"/instant-app/"},{"categories":null,"content":"运行instant app 01-12 07:47:39.436 813-825/system_process I/ActivityManager: START u0 {act=android.intent.action.VIEW cat=[android.intent.category.BROWSABLE] dat=https://jet.com/... flg=0x1c080000 cmp=com.jet.jet.app/com.jet.baselib.activities.RootActivity (has extras)} from uid 10017 jet安装成功后，chrome会再发出上面的intent来让系统处理这个url，这个时候查询到有jet这个app可以handle这个app，于是jet应用就被成功拉起来了； Q：安装了多个浏览器时，任意的浏览器其实都可以处理https://www.jet.com，为什么可以直接进入jet，而不是其他的浏览器app？ A：因为jet app最匹配https://www.jet.com这个URL 参考IntentFilter的匹配intent的流程： public final int matchData(String type, String scheme, Uri data) { if (schemes != null) { if (schemes.contains(scheme != null ? scheme : \"\")) { match = MATCH_CATEGORY_SCHEME; // 0x0200000 1. 先匹配scheme, 例如http/https或其他自定义scheme } else { return NO_MATCH_DATA; } final ArrayList\u003cPatternMatcher\u003e schemeSpecificParts = mDataSchemeSpecificParts; if (schemeSpecificParts != null \u0026\u0026 data != null) { match = hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA; } if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) { // If there isn't any matching ssp, we need to match an authority. final ArrayList\u003cAuthorityEntry\u003e authorities = mDataAuthorities; if (authorities != null) { int authMatch = matchDataAuthority(data); if (authMatch \u003e= 0) { final ArrayList\u003cPatternMatcher\u003e paths = mDataPaths; if (paths == null) { match = authMatch; } else if (hasDataPath(data.getPath())) { // 2. 再检查是否有更加匹配的path match = MATCH_CATEGORY_PATH; // 0x0500000 ... } } ... } if (types != null) { if (findMimeType(type)) { match = MATCH_CATEGORY_TYPE; // 0x0600000 3. 最后再匹配mime类型 } else { return NO_MATCH_TYPE; } } return match + MATCH_ADJUSTMENT_NORMAL; } 后续流程参考chooseBestActivity() → findPreferredActivity()，不赘述 ","date":"2018-01-18","objectID":"/instant-app/:3:3","tags":["instant_app","pkms"],"title":"Android Instant App简介","uri":"/instant-app/"},{"categories":null,"content":"运行时的限制 instant app无法查询到非instant app里声明的组件，除非是下面两种情况： 显示声明了组件可以被instant app查询到，即标签上增加了\"android:visibleToInstantApps=true”； 未显示申明visibleToInstantApps，但是该组件是Activity/Service，且其intent filter包含category_browsable/action_send(to)/action_send_multiple中任意一个； 非instant app无法查询instant app的组件 目前不支持发送通知 不允许动态加载native/java code 不支持静态注册的receiver，不支持定义或访问其他app的ContentProvider，service不能长期运行 ","date":"2018-01-18","objectID":"/instant-app/:3:4","tags":["instant_app","pkms"],"title":"Android Instant App简介","uri":"/instant-app/"},{"categories":null,"content":"小结 优点： 无需手动安装app，(浏览器里)点击链接即可进入原生app 基本和普通app一致的开发流程，模块化开发 缺点： 依赖google play store, gms, chrome等服务，政策原因，国内用不了~_~|| 目前支持的应用特别少 app开发要维护两个版本的代码 ","date":"2018-01-18","objectID":"/instant-app/:4:0","tags":["instant_app","pkms"],"title":"Android Instant App简介","uri":"/instant-app/"},{"categories":null,"content":"背景 Android 8.0在odex的基础上又引入了vdex机制，目的是为了降低dex2oat时间。 因为当系统ota后，用户自己安装的应用是不会发生任何变化的，但framework代码已经发生了变化， 所以就需要重新对这些应用也做dex2oat，所以如果有vdex的话，就可以省去重新校验apk里dex文件合法性的过程，节省一部分时间，所以本文分析下vdex的实现机制。 文件格式 用途 .dex 存储java字节码 .odex/.oat optimized dex，ELF格式 .vdex verified dex，包含 raw dex +（quicken info) .art image文件，存储热点方法string, method, types等 ","date":"2017-12-21","objectID":"/android-vdex/:0:1","tags":["dex2oat","vdex"],"title":"Android 8.0 VDEX机制简介","uri":"/android-vdex/"},{"categories":null,"content":"首个VDEX实现相关commit： commit 7b49e6cade09bc65b3b5f22d45fc9d0a7184e4f2 Author: David Brazdil \u003cdbrazdil@google.com\u003e Date: Thu Sep 1 11:06:18 2016 +0100 主要目的：降低dex2oat执行耗时 1、当系统OTA后，对于安装在data分区下的app，因为它们的apk都没有任何变化，那么在首次开机时，对于这部分app如果有vdex文件存在的话，执行dexopt时就可以直接跳过verify流程，进入compile dex的流程，从而加速首次开机速度； 2、当app的jit profile信息变化时，background dexopt会在后台重新做dex2oat，因为有了vdex，这个时候也可以直接跳过 ","date":"2017-12-21","objectID":"/android-vdex/:0:2","tags":["dex2oat","vdex"],"title":"Android 8.0 VDEX机制简介","uri":"/android-vdex/"},{"categories":null,"content":"原理 应用首次安装时，抽取出其中的dex文件，校验成功后，存储到一个独立的文件中，后面由于jit profile改变，或OTA等原因，而重新进行dexopt时，可以跳过dex文件校验流程 ","date":"2017-12-21","objectID":"/android-vdex/:0:3","tags":["dex2oat","vdex"],"title":"Android 8.0 VDEX机制简介","uri":"/android-vdex/"},{"categories":null,"content":"具体实现： dex2oat关键路径： main() → setup() → compileApp() // art/dex2oat/dexoat.cc int main(int argc, char** argv) { return static_cast\u003cint\u003e(art::Dex2oat(argc, argv)); } static dex2oat::ReturnCode Dex2oat(int argc, char** argv) { dex2oat-\u003eParseArgs(argc, argv); dex2oat::ReturnCode setup_code = dex2oat-\u003eSetup(); dex2oat::ReturnCode result = CompileApp(*dex2oat); return result; } dex2oat::ReturnCode Setup() { // DoDexLayoutOptimizations()内部会校验dex文件，所以当vdex存在或者DoDexLayoutOptimizations()也ok时 // 后面就不用再次去检查dex文件的合法性了 const bool verify = !DoDexLayoutOptimizations() \u0026\u0026 (input_vdex_file_ == nullptr); if (!oat_writers_[i]-\u003eWriteAndOpenDexFiles( kIsVdexEnabled ? vdex_files_[i].get() : oat_files_[i].get(), rodata_.back(), instruction_set_, instruction_set_features_.get(), key_value_store_.get(), verify, update_input_vdex_, \u0026opened_dex_files_map, \u0026opened_dex_files)) { return dex2oat::ReturnCode::kOther; } } 由于VDEX优化的是verfiy流程，即校验dex文件的合法性，所以下面主要看一下 WriteAndOpenDexFiles() 函数的实现 // art/compiler/oat_writer.cc bool OatWriter::WriteAndOpenDexFiles( File* vdex_file, OutputStream* oat_rodata, InstructionSet instruction_set, const InstructionSetFeatures* instruction_set_features, SafeMap\u003cstd::string, std::string\u003e* key_value_store, bool verify, bool update_input_vdex, /*out*/ std::unique_ptr\u003cMemMap\u003e* opened_dex_files_map, /*out*/ std::vector\u003cstd::unique_ptr\u003cconst DexFile\u003e\u003e* opened_dex_files) { ... if (kIsVdexEnabled) { std::unique_ptr\u003cBufferedOutputStream\u003e vdex_out( MakeUnique\u003cBufferedOutputStream\u003e(MakeUnique\u003cFileOutputStream\u003e(vdex_file))); // 启用了vdex，把dex文件写到vdex文件里，并map到内存里，用于后续compile流程 if (!WriteDexFiles(vdex_out.get(), vdex_file, update_input_vdex) || !OpenDexFiles(vdex_file, verify, \u0026dex_files_map, \u0026dex_files)) { return false; } } else { // 没有启用vdex，就把dex文件写到oat(odex)文件里 if (!WriteDexFiles(oat_rodata, vdex_file, update_input_vdex) || !OpenDexFiles(vdex_file, verify, \u0026dex_files_map, \u0026dex_files)) { return false; } } ... } 第1步：打开apk文件，把其中的classes[N].dex文件合并写入到vdex文件 WriteDexFiles流程：此处略过，见后文vdex的生成过程 第2步：map vdex文件到内存，用于后续对其中的dex文件做优化，并写入到odex文件。 如果vdex是刚刚创建的，则还需要vdex里的dex文件部分是否合法，否则便可跳过校验流程，直接进行后续的代码优化流程 OpenDexFiles流程：OatWriter::OpenDexFiles -\u003e DexFile::Open -\u003e DexFile::OpenCommon -\u003e DexFileVerifier::Verify DexFileVerifier::Verify的主流程： // art/runtime/dex_file_verifier.cc bool DexFileVerifier::Verify() { // Check the header. if (!CheckHeader()) { return false; } // Check the map section. if (!CheckMap()) { return false; } // Check structure within remaining sections. if (!CheckIntraSection()) { return false; } // Check references from one section to another. return CheckInterSection(); } 结合一下dex文件的格式： 字段含义对照表： 名称 格式 说明 header header_item 标头 string_ids string_id_item[] 字符串标识符列表。这些是此文件使用的所有字符串的标识符，用于内部命名（例如类型描述符）或用作代码引用的常量对象。此列表必须使用 UTF-16 代码点值按字符串内容进行排序（不采用语言区域敏感方式），且不得包含任何重复条目。 type_ids type_id_item[] 类型标识符列表。这些是此文件引用的所有类型（类、数组或原始类型）的标识符（无论文件中是否已定义）。此列表必须按 string_id 索引进行排序，且不得包含任何重复条目。 proto_ids proto_id_item[] 方法原型标识符列表。这些是此文件引用的所有原型的标识符。此列表必须按返回类型（按 type_id 索引排序）主要顺序进行排序，然后按参数列表（按 type_id 索引排序的各个参数，采用字典排序方法）进行排序。该列表不得包含任何重复条目。 field_ids field_id_item[] 字段标识符列表。这些是此文件引用的所有字段的标识符（无论文件中是否已定义）。此列表必须进行排序，其中定义类型（按 type_id 索引排序）是主要顺序，字段名称（按 string_id 索引排序）是中间顺序，而类型（按 type_id 索引排序）是次要顺序。该列表不得包含任何重复条目。 method_ids method_id_item[] 方法标识符列表。这些是此文件引用的所有方法的标识符（无论文件中是否已定义）。此列表必须进行排序，其中定义类型（按 type_id 索引排序）是主要顺序，方法名称（按 string_id 索引排序）是中间顺序，而方法原型（按 proto_id 索引排序）是次要顺序。该列表不得包含任何重复条目。 class_defs class_def_item[] 类定义列表。这些类必须进行排序，以便所指定类的超类和已实现的接口比引用类更早出现在该列表中。此外，对于在该列表中多次出现的同名类，其定义是无效的。 call_site_ids call_site_id_item[] 调用站点标识符列表。这些是此文件引用的所有调用站点的标识符（无论文件中是否已定义）。此列表必须按 call_site_off 的升序进行排序。 method_handles method_handle_item[] 方法句柄列表。此文件引用的所有方法句柄的列表（无论文件中是否已定义）。此列表未进行排序，而且可能包含将在逻辑上对应于不同方法句柄实例的重复项。 data ubyte[] 数据区，包含上面所列表格的所有支持数据。不同的项有不同的对齐要求；如有必要，则在每个项之前插入填充字节，以实现所需的对齐效果。 link_data ubyte[] 静态链接文件中使用的数据。本文档尚未指定本区段中数据的格式。此区段在未链接文件中为空，而运行时实现可能会在适当的情况下使用这些数据。 CheckHeader()：校验dex头信息(见上面dex文件结构图左半部分) 校验实际文件大小与dex头文件里保存的file_size是否一致； 计算dex文件的checksum，然后与dex头里保存的checksum对比，检查是否一","date":"2017-12-21","objectID":"/android-vdex/:0:4","tags":["dex2oat","vdex"],"title":"Android 8.0 VDEX机制简介","uri":"/android-vdex/"},{"categories":null,"content":"vdex的生成过程 vdex文件结构 | magic: 4字节 | version: 4字节 | dex[0] | dex[1] | … | dex[N] | 定义见：art/runtime/vdex_file.h 生成过程 OatWriter:WriteAndOpenDexFiles() -\u003e WriteDexFiles() -\u003e WriteDexFile() -\u003e ZipEntry.extraTo(vdex_file) -\u003e WriteVdexHeader() 这一步主流程很简单，就是把apk里的dex文件抽取抽取然后写入到vdex文件里，最后写入vdex版本号和校验和，比较麻烦的是写入文件的时候要做4字节对齐，所以每次写入一个dex文件都要先设置好文件偏移，这样后面map这个vdex里时候能够提高效率。 ","date":"2017-12-21","objectID":"/android-vdex/:0:5","tags":["dex2oat","vdex"],"title":"Android 8.0 VDEX机制简介","uri":"/android-vdex/"},{"categories":null,"content":"主流app的dex文件校验耗时: App名称 版本 dex文件总大小/包体积 verify耗时 dex2oat总耗时(4线程) 微信 6.5.23 41.8Mb / 54Mb 2.681秒 13.376秒 支付宝 10.1.8.112305 40.8Mb / 58Mb 2.768秒 13.764秒 淘宝 7.2.3 11.6Mb / 76Mb 692毫秒 3.641秒 今日头条极速版 6.1.9 4.8Mb / 2.9Mb 242毫秒 1.899s ","date":"2017-12-21","objectID":"/android-vdex/:0:6","tags":["dex2oat","vdex"],"title":"Android 8.0 VDEX机制简介","uri":"/android-vdex/"},{"categories":null,"content":"新版VDEX结构 到Android 9.0上，vdex结构变的丰富了： // VDEX files contain extracted DEX files. The VdexFile class maps the file to // memory and provides tools for accessing its individual sections. // // File format: // VdexFile::VerifierDepsHeader fixed-length header // Dex file checksums // // Optionally: // VdexFile::DexSectionHeader fixed-length header // // quicken_table_off[0] offset into QuickeningInfo section for offset table for DEX[0]. // DEX[0] array of the input DEX files, the bytecode may have been quickened. // quicken_table_off[1] // DEX[1] // ... // DEX[D] // // VerifierDeps // uint8[D][] verification dependencies // // Optionally: // QuickeningInfo // uint8[D][] quickening data // uint32[D][] quickening data offset tables 增加了VerifierDeps和QuickeningInfo，其中VerifierDeps是用于快速校验dex里method合法性的，它是在第一次dex2oat的时候生成， 后面再做dex2oat的时候可以根据这个信息，就不用挨个分析字节码了（虚拟机总是向前兼容的），只要确认依赖的类存在就ok了，详细可以看： commit ca3c8c33501bf199d6fd0a5db30a27d8e010cb23 Author: David Brazdil \u003cdbrazdil@google.com\u003e Date: Tue Sep 6 14:04:48 2016 +0100 Collect verifier dependencies MethodVerifier tests whether a DEX method is valid w.r.t. the classes in class path. Since the APK does not change across OTA updates, it is not necessary to analyze the bytecode again with MethodVerifier, as long as its dependencies on the class path (which may have changed) are satisfied. This patch introduces VerifierDeps, a class path dependency collector, and adds hooks into MethodVerifier where classes/methods/fields are resolved and where assignability of types is tested. ","date":"2017-12-21","objectID":"/android-vdex/:0:7","tags":["dex2oat","vdex"],"title":"Android 8.0 VDEX机制简介","uri":"/android-vdex/"}]